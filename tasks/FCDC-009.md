# Task FCDC-009: Native Type Code Emitter

**ID:** FCDC-009  
**Title:** Native Type Code Emitter  
**Status:** ðŸ”´ Not Started  
**Priority:** Critical  
**Phase:** 2 - Roslyn Source Generator  
**Estimated Effort:** 6-8 days  
**Dependencies:** FCDC-008 (Alignment and Layout Calculator)  
**Complexity:** High

---

## Overview

Generate TNative blittable struct types that exactly match Cyclone DDS C memory layouts. These structs are used directly by P/Invoke calls to dds_write/dds_take and must be unmanaged, correctly aligned, and compatible with Cyclone's type descriptors generated by idlc.

**Design Reference:** [Detailed Design Â§5.1 Phase 4 Native Type Generation](../docs/FCDC-DETAILED-DESIGN.md#51-roslyn-source-generator-flow), [Â§8 Type System](../docs/FCDC-DETAILED-DESIGN.md#8-type-system), [Â§9.3 Union Native Layout](../docs/FCDC-DETAILED-DESIGN.md#93-generated-native-layout)

---

## Objectives

1. Implement TNative struct code emitter for topic types
2. Implement TNative struct code emitter for union types
3. Generate correct [StructLayout] attributes (Sequential or Explicit)
4. Generate fixed buffers for bounded data (FixedString32 â†’ fixed byte[32])
5. Generate pointer+length structs for unbounded data (Utf8StringRef, SeqFloat)
6. Generate explicit layout unions with correct [FieldOffset] calculations
7. Emit debug asserts for sizeof/offsetof validation
8. Handle nested schema types correctly
9. Apply global type mappings (Guid â†’ Guid16, etc.)

---

## Acceptance Criteria

- [ ] TNative structs are generated with correct namespace and naming convention
- [ ] All TNative types satisfy `unmanaged` constraint (no object references)
- [ ] [StructLayout(LayoutKind.Sequential)] for normal structs
- [ ] [StructLayout(LayoutKind.Explicit)] for unions with correct field offsets
- [ ] Fixed buffers generated for bounded strings (e.g., `fixed byte Bytes[32]`)
- [ ] Pointer+length structs generated for unbounded strings/sequences
- [ ] Nested schema types are inlined correctly
- [ ] Optional members generate presence wrapper structs
- [ ] Union payload offsets calculated using alignment calculator (FCDC-008)
- [ ] Global type map applied (Guid â†’ Guid16Native with fixed byte[16])
- [ ] Enum types mapped correctly (underlying type matches IDL)
- [ ] Debug builds include sizeof/offsetof assertions
- [ ] Generated code compiles without errors/warnings
- [ ] Generated structs can be passed to unsafe P/Invoke methods

---

## Implementation Details

### File Structure (Generated Code)

```
Generated/
â””â”€â”€ {TypeName}Native.g.cs
```

### Code Emitter (Emitters/NativeTypeEmitter.cs)

```csharp
using Microsoft.CodeAnalysis;
using System.Text;

namespace Bagira.CycloneDDS.Generator.Emitters
{
    internal sealed class NativeTypeEmitter
    {
        private readonly SchemaTopicType _schemaType;
        private readonly AlignmentCalculator _alignmentCalc;
        private readonly GlobalTypeMapResolver _typeMapResolver;

        public NativeTypeEmitter(
            SchemaTopicType schemaType,
            AlignmentCalculator alignmentCalc,
            GlobalTypeMapResolver typeMapResolver)
        {
            _schemaType = schemaType;
            _alignmentCalc = alignmentCalc;
            _typeMapResolver = typeMapResolver;
        }

        public string EmitNativeStruct()
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using Bagira.CycloneDDS.Runtime;");
            sb.AppendLine();

            // Namespace
            sb.AppendLine($"namespace {_schemaType.Symbol.ContainingNamespace.ToDisplayString()}");
            sb.AppendLine("{");

            // Struct definition
            EmitStructDefinition(sb);

            sb.AppendLine("}");

            return sb.ToString();
        }

        private void EmitStructDefinition(StringBuilder sb)
        {
            var nativeName = $"{_schemaType.Symbol.Name}Native";

            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Native blittable representation of {_schemaType.Symbol.Name}.");
            sb.AppendLine($"    /// This type matches the Cyclone DDS C memory layout exactly.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    [StructLayout(LayoutKind.Sequential)]");
            sb.AppendLine($"    public unsafe struct {nativeName}");
            sb.AppendLine($"    {{");

            // Emit fields
            foreach (var field in _schemaType.Fields)
            {
                EmitField(sb, field);
            }

            // Emit debug assertions in #if DEBUG
            sb.AppendLine();
            sb.AppendLine("#if DEBUG");
            sb.AppendLine($"        static {nativeName}()");
            sb.AppendLine($"        {{");
            sb.AppendLine($"            // Validate struct size matches expectations");
            sb.AppendLine($"            var expectedSize = {CalculateExpectedSize()};");
            sb.AppendLine($"            var actualSize = sizeof({nativeName});");
            sb.AppendLine($"            System.Diagnostics.Debug.Assert(actualSize >= expectedSize,");
            sb.AppendLine($"                $\"Native struct size mismatch: expected >= {{expectedSize}}, got {{actualSize}}\");");
            sb.AppendLine($"        }}");
            sb.AppendLine("#endif");

            sb.AppendLine($"    }}");
        }

        private void EmitField(StringBuilder sb, SchemaField field)
        {
            var nativeType = MapToNativeType(field);

            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// Native representation of {field.Name}.");
            sb.AppendLine($"        /// </summary>");
            sb.AppendLine($"        public {nativeType} {field.Name};");
        }

        private string MapToNativeType(SchemaField field)
        {
            // Check global type map first
            if (_typeMapResolver.TryGetMapping(field.Type, out var wireKind))
            {
                return GetNativeTypeForWireKind(wireKind);
            }

            // Check for unbounded string
            if (field.Type.SpecialType == SpecialType.System_String && field.Bound == null)
            {
                return "Utf8StringRef";
            }

            // Check for bounded string (FixedString32, etc.)
            if (IsFixedStringType(field.Type, out var stringSize))
            {
                return $"FixedString{stringSize}Native";
            }

            // Check for unbounded array/sequence
            if (IsArrayType(field.Type, out var elementType) && field.Bound == null)
            {
                var nativeElementType = MapToNativeType(new SchemaField
                {
                    Symbol = field.Symbol,
                    Name = field.Name,
                    Type = elementType,
                    IsKey = false,
                    IsOptional = false
                });
                return $"Seq<{nativeElementType}>";
            }

            // Check for optional
            if (field.IsOptional)
            {
                var innerType = MapToNativeType(new SchemaField
                {
                    Symbol = field.Symbol,
                    Name = field.Name,
                    Type = field.Type,
                    IsKey = false,
                    IsOptional = false
                });
                return $"Optional<{innerType}>";
            }

            // Primitive types
            return field.Type.SpecialType switch
            {
                SpecialType.System_Byte => "byte",
                SpecialType.System_SByte => "sbyte",
                SpecialType.System_Int16 => "short",
                SpecialType.System_UInt16 => "ushort",
                SpecialType.System_Int32 => "int",
                SpecialType.System_UInt32 => "uint",
                SpecialType.System_Int64 => "long",
                SpecialType.System_UInt64 => "ulong",
                SpecialType.System_Single => "float",
                SpecialType.System_Double => "double",
                SpecialType.System_Boolean => "byte", // bool mapped to byte for determinism
                _ => $"{field.Type.Name}Native" // Nested schema type
            };
        }

        private string GetNativeTypeForWireKind(DdsWireKind wireKind)
        {
            return wireKind switch
            {
                DdsWireKind.Guid16 => "Guid16Native",
                DdsWireKind.Int64TicksUtc => "long",
                DdsWireKind.QuaternionF32x4 => "QuaternionF32x4Native",
                DdsWireKind.FixedUtf8Bytes32 => "FixedString32Native",
                DdsWireKind.FixedUtf8Bytes64 => "FixedString64Native",
                DdsWireKind.FixedUtf8Bytes128 => "FixedString128Native",
                _ => throw new NotSupportedException($"Wire kind {wireKind} not supported")
            };
        }

        private int CalculateExpectedSize()
        {
            int size = 0;
            foreach (var field in _schemaType.Fields)
            {
                var fieldSize = _alignmentCalc.GetTypeSize(field.Type);
                var fieldAlign = _alignmentCalc.GetTypeAlignment(field.Type);

                // Add padding for alignment
                if (size % fieldAlign != 0)
                    size += fieldAlign - (size % fieldAlign);

                size += fieldSize;
            }

            // Add final padding to struct alignment
            var structAlign = _schemaType.Fields.Max(f => _alignmentCalc.GetTypeAlignment(f.Type));
            if (size % structAlign != 0)
                size += structAlign - (size % structAlign);

            return size;
        }
    }
}
```

### Union Native Type Emitter

```csharp
private void EmitUnionStructDefinition(StringBuilder sb)
{
    var nativeName = $"{_schemaUnion.Symbol.Name}Native";
    var discriminatorType = _schemaUnion.DiscriminatorField.Type.Name;

    // Calculate payload offset using alignment calculator
    var discriminatorSize = _alignmentCalc.GetTypeSize(_schemaUnion.DiscriminatorField.Type);
    var maxArmAlignment = _schemaUnion.Arms.Max(arm =>
        _alignmentCalc.GetTypeAlignment(arm.Field.Type));
    var payloadOffset = (discriminatorSize + (maxArmAlignment - 1)) & ~(maxArmAlignment - 1);

    sb.AppendLine($"    [StructLayout(LayoutKind.Explicit)]");
    sb.AppendLine($"    public unsafe struct {nativeName}");
    sb.AppendLine($"    {{");

    // Discriminator at offset 0
    sb.AppendLine($"        [FieldOffset(0)]");
    sb.AppendLine($"        public {discriminatorType} Kind;");
    sb.AppendLine();

    // Each arm at calculated payload offset
    foreach (var arm in _schemaUnion.Arms)
    {
        var armNativeType = MapToNativeType(arm.Field);
        sb.AppendLine($"        [FieldOffset({payloadOffset})]");
        sb.AppendLine($"        public {armNativeType} {arm.Field.Name};");
    }

    sb.AppendLine($"    }}");
}
```

### Helper Structs (CommonTypes Generator)

These are emitted once per compilation:

```csharp
// Utf8StringRef.g.cs
[StructLayout(LayoutKind.Sequential)]
public unsafe struct Utf8StringRef
{
    public byte* Ptr;
    public int ByteLen;
}

// SeqGeneric.g.cs
[StructLayout(LayoutKind.Sequential)]
public unsafe struct Seq<T> where T : unmanaged
{
    public T* Ptr;
    public int Len;
}

// Guid16Native.g.cs
[StructLayout(LayoutKind.Sequential)]
public unsafe struct Guid16Native
{
    public fixed byte Bytes[16];
}

// FixedString32Native.g.cs
[StructLayout(LayoutKind.Sequential)]
public unsafe struct FixedString32Native
{
    public fixed byte Bytes[32];
}

// OptionalGeneric.g.cs
[StructLayout(LayoutKind.Sequential)]
public unsafe struct Optional<T> where T : unmanaged
{
    public byte HasValue;  // 0 or 1
    // Padding handled by runtime
    public T Value;
}
```

---

## Testing Requirements

### Unit Tests

1. **Struct Layout Tests**
   - Verify sizeof(TNative) matches expected size
   - Verify field offsets are correct (via Marshal.OffsetOf)
   - Verify struct satisfies `unmanaged` constraint

2. **Primitive Mapping Tests**
   - All C# primitives map to correct native types
   - bool â†’ byte (not bool, for size determinism)
   - Enums map correctly

3. **Bounded Data Tests**
   - FixedString32 â†’ fixed byte[32]
   - BoundedSeq<T, 10> â†’ inline array or bounded storage

4. **Unbounded Data Tests**
   - string â†’ Utf8StringRef (pointer + length)
   - T[] â†’ Seq<T> (pointer + length)

5. **Optional Tests**
   - T? â†’ Optional<T> with presence byte + value
   - Verify alignment and size

6. **Union Layout Tests**
   - Discriminator at offset 0
   - All arms at same calculated offset
   - Offset calculation is correct (no hardcoded 4!)
   - Union with double/long has correct 8-byte alignment

7. **Global Type Map Tests**
   - Guid â†’ Guid16Native (fixed byte[16])
   - DateTime â†’ long
   - Custom Quaternion â†’ QuaternionF32x4Native

8. **Nested Types Tests**
   - Nested schema types inlined correctly
   - Recursive nesting fails with diagnostic (not supported)

---

## Known Challenges

### 1. Union Alignment Calculation
**Challenge:** C-compatible union layout requires calculating padding between discriminator and payload based on strictest arm alignment.

**Solution:** Use AlignmentCalculator from FCDC-008. Do NOT hardcode offset to 4 bytes.

**Test Case:**
```csharp
[DdsUnion]
public partial class TestUnion
{
    [DdsDiscriminator]
    public int Kind;  // 4 bytes

    [DdsCase(1)]
    public double Value;  // 8-byte alignment required
}
```
Expected: Payload offset = 8 (not 4), because double requires 8-byte alignment.

### 2. Fixed Buffers Require `unsafe`
**Challenge:** Generated code with fixed buffers requires `unsafe` context.

**Solution:** Mark generated struct as `unsafe`, document requirement for consumer projects to enable `<AllowUnsafeBlocks>true</AllowUnsafeBlocks>`.

### 3. Generic Seq<T> and Optional<T>
**Challenge:** Cannot generate generic structs per topic (code duplication).

**Solution:** Emit common Seq<T> and Optional<T> once per compilation in a "CommonTypes.g.cs" file.

---

## Documentation Requirements

- [ ] XML documentation on all generated TNative types
- [ ] Document unsafe requirement for consumer projects
- [ ] Document struct layout guarantees and compatibility

---

## Definition of Done

- All acceptance criteria met
- Unit and integration tests pass
- Generated TNative code compiles with zero warnings
- TNative structs can be passed to P/Invoke methods
- Union alignment is correct for all test cases
- Code review approved
- Integration with FCDC-011 (marshallers) works correctly
