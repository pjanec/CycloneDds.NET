# Zero-Copy Read - Task Details

**Project:** FastCycloneDDS C# Bindings  
**Feature:** Zero-Copy / Zero-Allocation Read Path  
**Created:** 2026-02-01  
**Last Updated:** 2026-02-01

**Reference:** [ZERO-COPY-READ-DESIGN.md](ZERO-COPY-READ-DESIGN.md)

---

## Architecture Overview: The Three Types

**CRITICAL:** This feature introduces a **third type** for every IDL definition. Understanding the distinction is essential.

### The Three Type Representations

1. **DSL Structs (User Types)**
   - Purpose: Application layer, developer-friendly API
   - Storage: Heap-allocated (class or regular struct)
   - Fields: Use `string`, `List<T>`, nested objects
   - Ownership: Fully owned by user code
   - Example:
   ```csharp
   // User-defined in application code
   public class CameraImage
   {
       public uint Id { get; set; }
       public string Name { get; set; }      // Heap string
       public List<byte> Pixels { get; set; } // Heap collection
   }
   ```

2. **Native Structs (Ghost Types)**
   - Purpose: C ABI layout, internal marshalling
   - Storage: Stack or unmanaged heap
   - Fields: `fixed`, pointers, `NativeSequence<T>`, `NativeString`
   - Visibility: `internal unsafe`
   - Example:
   ```csharp
   // Generated by code generator
   [StructLayout(LayoutKind.Sequential)]
   internal unsafe struct CameraImage_Native
   {
       public uint id;
       public NativeString name;            // Pointer + length
       public NativeSequence<byte> pixels;  // Buffer + length
   }
   ```

3. **View Structs (Zero-Copy Views) - NEW**
   - Purpose: Zero-copy, zero-allocation read access
   - Storage: Stack-only (`ref struct`)
   - Fields: Properties that dereference pointers
   - Lifetime: Tied to DdsLoan scope
   - Example:
   ```csharp
   // Generated by this feature
   public readonly ref struct CameraImageView
   {
       private readonly unsafe CameraImage_Native* _ptr;
       
       public uint Id => _ptr->id;
       
       // Returns span over native UTF-8 bytes (zero-copy)
       public ReadOnlySpan<byte> GetNameUtf8() => ...;
       
       // Returns span over native pixel buffer (zero-copy)
       public ReadOnlySpan<byte> Pixels => ...;
   }
   ```

### Two Usage Paths

**Path 1: Zero-Copy (Fast)**
```csharp
using var loan = reader.Read();
foreach (var sample in loan)
{
    if (!sample.IsValid) continue;
    
    var view = sample.AsView();  // No allocation, stack pointer
    ProcessImage(view);          // Pass by ref, zero-copy
}
// loan.Dispose() → native memory returned to DDS
```

**Path 2: Managed Copy (Convenient)**
```csharp
var images = new List<CameraImage>();
using (var loan = reader.Read())
{
    foreach (var sample in loan)
    {
        if (!sample.IsValid) continue;
        
        var managed = sample.AsView().ToManaged(); // Deep copy
        images.Add(managed);                        // Can outlive loan
    }
}
// Now images contain fully owned copies
```

### Key Insights

- **Views are NOT DSL structs**: The View is a separate generated type that provides read-only access to native memory
- **Views cannot be stored**: Cannot add `CameraImageView` to `List<>`, cannot capture in lambdas, cannot use across `await`
- **Compiler enforces safety**: `ref struct` prevents views from escaping the loan scope
- **Dynamic data patterns**:
  - Strings: `ReadOnlySpan<byte>` (UTF-8), decode on access
  - Primitive sequences: `ReadOnlySpan<T>` (zero-copy)
  - Struct sequences: Indexer + flyweight pattern (no `Span<View>` possible)

---

## Task Index

### Phase 1: Runtime Infrastructure
- [FCDC-ZC001](#fcdc-zc001-create-ddssampleref-struct) - Create DdsSampleRef Struct
- [FCDC-ZC002](#fcdc-zc002-modify-ddsloan-remove-generic) - Modify DdsLoan (Remove Generic)
- [FCDC-ZC003](#fcdc-zc003-update-ddsloan-enumerator) - Update DdsLoan Enumerator
- [FCDC-ZC004](#fcdc-zc004-modify-ddsreader-read-method) - Modify DdsReader.Read() Method
- [FCDC-ZC005](#fcdc-zc005-add-text-encoding-helper) - Add Text Encoding Helper

### Phase 2: Code Generation - View Structs
- [FCDC-ZC006](#fcdc-zc006-create-viewstruct-emitter-infrastructure) - Create ViewStruct Emitter Infrastructure
- [FCDC-ZC007](#fcdc-zc007-emit-primitive-field-accessors) - Emit Primitive Field Accessors
- [FCDC-ZC008](#fcdc-zc008-emit-string-field-accessors) - Emit String Field Accessors
- [FCDC-ZC009](#fcdc-zc009-emit-primitive-sequence-accessors) - Emit Primitive Sequence Accessors
- [FCDC-ZC010](#fcdc-zc010-emit-struct-sequence-accessors) - Emit Struct Sequence Accessors
- [FCDC-ZC011](#fcdc-zc011-emit-string-sequence-accessors) - Emit String Sequence Accessors
- [FCDC-ZC012](#fcdc-zc012-emit-fixed-array-accessors) - Emit Fixed Array Accessors
- [FCDC-ZC013](#fcdc-zc013-emit-union-accessors) - Emit Union Accessors
- [FCDC-ZC014](#fcdc-zc014-emit-optional-field-accessors) - Emit Optional Field Accessors

### Phase 3: Code Generation - Extension Methods
- [FCDC-ZC015](#fcdc-zc015-create-extension-method-emitter) - Create Extension Method Emitter
- [FCDC-ZC016](#fcdc-zc016-verify-extension-method-inlining) - Verify Extension Method Inlining

### Phase 4: Code Generation - ToManaged
- [FCDC-ZC017](#fcdc-zc017-create-tomanaged-emitter) - Create ToManaged Emitter
- [FCDC-ZC018](#fcdc-zc018-implement-readcopied-extension) - Implement ReadCopied Extension

### Phase 5: Edge Cases & Fixes
- [FCDC-ZC019](#fcdc-zc019-fix-multidimensional-array-flattening) - Fix Multi-Dimensional Array Flattening
- [FCDC-ZC020](#fcdc-zc020-implement-sequence-of-strings) - Implement Sequence-of-Strings Handling
- [FCDC-ZC021](#fcdc-zc021-implement-boolean-sequence-safety) - Implement Boolean Sequence Safety
- [FCDC-ZC022](#fcdc-zc022-handle-keyed-topics) - Handle Keyed Topics & Lifecycle Events

### Phase 6: Testing & Validation
- [FCDC-ZC023](#fcdc-zc023-runtime-unit-tests) - Runtime Unit Tests
- [FCDC-ZC024](#fcdc-zc024-view-unit-tests) - View Unit Tests
- [FCDC-ZC025](#fcdc-zc025-roundtrip-integration-tests) - Round-Trip Integration Tests
- [FCDC-ZC026](#fcdc-zc026-allocation-performance-tests) - Allocation/Performance Tests
- [FCDC-ZC027](#fcdc-zc027-interop-compatibility-tests) - Interop/Compatibility Tests

### Phase 7: Documentation
- [FCDC-ZC028](#fcdc-zc028-api-documentation) - API Documentation
- [FCDC-ZC029](#fcdc-zc029-migration-guide) - Migration Guide
- [FCDC-ZC030](#fcdc-zc030-performance-best-practices) - Performance Best Practices Guide

---

## Phase 1: Runtime Infrastructure

### FCDC-ZC001: Create DdsSampleRef Struct

**Description:**  
Create a new `ref struct` that serves as a lightweight, type-agnostic handle to a single DDS sample in native memory. This struct holds a raw pointer and metadata reference without interpreting the data type.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 4.1](ZERO-COPY-READ-DESIGN.md#41-ddssampleref-runtime---new)

**Files to Create:**
- `src/CycloneDDS.Runtime/DdsSampleRef.cs`

**Implementation Details:**

```csharp
namespace CycloneDDS.Runtime
{
    /// <summary>
    /// A transient reference to a DDS sample in native memory.
    /// Acts as the bridge between the generic Loan and the typed View.
    /// Must be stack-allocated (ref struct) to prevent escaping the loan scope.
    /// </summary>
    public readonly ref struct DdsSampleRef
    {
        /// <summary>
        /// Pointer to the native C struct (populated by dds_take).
        /// </summary>
        public readonly IntPtr DataPtr;

        /// <summary>
        /// Sample metadata (timestamp, instance state, validity, etc).
        /// Passed by ref to avoid copying 160-byte struct.
        /// </summary>
        public readonly ref readonly DdsApi.DdsSampleInfo Info;

        public DdsSampleRef(IntPtr dataPtr, ref DdsApi.DdsSampleInfo info)
        {
            DataPtr = dataPtr;
            Info = ref info;
        }

        /// <summary>
        /// True if this sample contains valid data (vs metadata-only like DISPOSE).
        /// </summary>
        public bool IsValid => Info.ValidData != 0;
    }
}
```

**Success Criteria:**

1. **Compilation Test:**
   ```csharp
   [TestMethod]
   public void DdsSampleRef_Compiles_AsRefStruct()
   {
       // Verify it's a ref struct by attempting to box (should fail to compile)
       // Manual verification: uncommenting should cause CS8345
       // object boxed = new DdsSampleRef(IntPtr.Zero, ref info);
   }
   ```

2. **Property Access Test:**
   ```csharp
   [TestMethod]
   public void DdsSampleRef_DataPtr_ReturnsCorrectPointer()
   {
       var ptr = new IntPtr(0x12340000);
       var info = new DdsApi.DdsSampleInfo { ValidData = 1 };
       var sampleRef = new DdsSampleRef(ptr, ref info);
       
       Assert.AreEqual(ptr, sampleRef.DataPtr);
   }
   ```

3. **IsValid Logic Test:**
   ```csharp
   [TestMethod]
   public void DdsSampleRef_IsValid_ReturnsTrueForValidData()
   {
       var info = new DdsApi.DdsSampleInfo { ValidData = 1 };
       var sampleRef = new DdsSampleRef(IntPtr.Zero, ref info);
       Assert.IsTrue(sampleRef.IsValid);
   }

   [TestMethod]
   public void DdsSampleRef_IsValid_ReturnsFalseForInvalidData()
   {
       var info = new DdsApi.DdsSampleInfo { ValidData = 0 };
       var sampleRef = new DdsSampleRef(IntPtr.Zero, ref info);
       Assert.IsFalse(sampleRef.IsValid);
   }
   ```

**Effort:** 2 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** None

---

### FCDC-ZC002: Modify DdsLoan (Remove Generic)

**Description:**  
Refactor `DdsLoan<T>` to remove the generic type parameter and the `NativeUnmarshalDelegate<T>` field. This prepares it to work with type-agnostic `DdsSampleRef` instead of typed data.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 4.2](ZERO-COPY-READ-DESIGN.md#42-ddsloan-runtime---modified)

**Files to Modify:**
- `src/CycloneDDS.Runtime/DdsLoan.cs`

**Implementation Steps:**

1. **Remove Generic Parameter:**
   ```csharp
   // Before:
   public ref struct DdsLoan<T> { ... }
   
   // After:
   public ref struct DdsLoan { ... }
   ```

2. **Remove Unmarshaller Field:**
   ```csharp
   // Remove:
   private readonly NativeUnmarshalDelegate<T> _unmarshaller;
   ```

3. **Update Constructor:**
   ```csharp
   // Before:
   public DdsLoan(
       DdsEntityHandle reader,
       IntPtr[] samples,
       DdsApi.DdsSampleInfo[] infos,
       int length,
       NativeUnmarshalDelegate<T> unmarshaller)
   
   // After:
   public DdsLoan(
       DdsEntityHandle reader,
       IntPtr[] samples,
       DdsApi.DdsSampleInfo[] infos,
       int length)
   {
       _reader = reader;
       _samples = samples;
       _infos = infos;
       _length = length;
       _disposed = false;
   }
   ```

4. **Keep Dispose Logic (Unchanged):**
   ```csharp
   public void Dispose()
   {
       if (_disposed) return;
       _disposed = true;

       if (_length > 0)
       {
           DdsApi.dds_return_loan(_reader.NativeHandle.Handle, _samples, _length);
       }

       ArrayPool<IntPtr>.Shared.Return(_samples);
       ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(_infos);
   }
   ```

**Success Criteria:**

1. **Compilation Test:**
   ```csharp
   [TestMethod]
   public void DdsLoan_Compiles_WithoutGenericParameter()
   {
       // Should compile without <T>
       DdsLoan loan = default;
   }
   ```

2. **Dispose Test:**
   ```csharp
   [TestMethod]
   public void DdsLoan_Dispose_ReturnsLoanToDds()
   {
       // Mock DdsApi.dds_return_loan
       var reader = CreateMockReader();
       var samples = new IntPtr[10];
       var infos = new DdsApi.DdsSampleInfo[10];
       
       var loan = new DdsLoan(reader, samples, infos, 5);
       loan.Dispose();
       
       // Verify dds_return_loan was called with correct parameters
       // Verify arrays returned to pool
   }
   ```

3. **Double Dispose Test:**
   ```csharp
   [TestMethod]
   public void DdsLoan_Dispose_CalledTwice_DoesNotThrow()
   {
       var loan = CreateTestLoan();
       loan.Dispose();
       loan.Dispose(); // Should be idempotent
   }
   ```

**Effort:** 3 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** None

---

### FCDC-ZC003: Update DdsLoan Enumerator

**Description:**  
Modify the `DdsLoan.Enumerator` to yield `DdsSampleRef` instead of `DdsSample<T>`. Remove unmarshalling logic from `MoveNext()`.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 4.2](ZERO-COPY-READ-DESIGN.md#42-ddsloan-runtime---modified)

**Files to Modify:**
- `src/CycloneDDS.Runtime/DdsLoan.cs`

**Implementation Details:**

```csharp
public ref struct DdsLoan
{
    // ... fields ...

    public LoanEnumerator GetEnumerator() => new LoanEnumerator(this);

    /// <summary>
    /// Stack-based enumerator (avoids IEnumerator boxing).
    /// </summary>
    public ref struct LoanEnumerator
    {
        private readonly DdsLoan _loan;
        private int _index;

        public LoanEnumerator(DdsLoan loan)
        {
            _loan = loan;
            _index = -1;
        }

        public bool MoveNext()
        {
            _index++;
            return _index < _loan._length;
        }

        public DdsSampleRef Current
        {
            get
            {
                // Return ref struct wrapping pointer and metadata
                return new DdsSampleRef(
                    _loan._samples[_index],
                    ref _loan._infos[_index]
                );
            }
        }
    }
}
```

**Success Criteria:**

1. **Enumeration Test:**
   ```csharp
   [TestMethod]
   public void DdsLoan_Enumerate_YieldsDdsSampleRefs()
   {
       var samples = new IntPtr[] { new IntPtr(0x1000), new IntPtr(0x2000) };
       var infos = new DdsApi.DdsSampleInfo[] 
       { 
           new DdsApi.DdsSampleInfo { ValidData = 1 },
           new DdsApi.DdsSampleInfo { ValidData = 0 }
       };
       
       var loan = new DdsLoan(mockReader, samples, infos, 2);
       
       int count = 0;
       foreach (var sample in loan)
       {
           Assert.IsTrue(sample.DataPtr == samples[count]);
           count++;
       }
       
       Assert.AreEqual(2, count);
   }
   ```

2. **Zero Allocation Test:**
   ```csharp
   [TestMethod]
   public void DdsLoan_Enumerate_AllocatesNothing()
   {
       var loan = CreateTestLoan(100);
       
       long gen0Before = GC.CollectionCount(0);
       
       foreach (var sample in loan)
       {
           _ = sample.DataPtr; // Access field
       }
       
       long gen0After = GC.CollectionCount(0);
       Assert.AreEqual(0, gen0After - gen0Before);
   }
   ```

3. **Ref Struct Behavior Test:**
   ```csharp
   [TestMethod]
   public void LoanEnumerator_IsRefStruct_CannotBox()
   {
       // Manual verification: uncommenting should cause CS8345
       // var loan = CreateTestLoan();
       // IEnumerator enumerator = loan.GetEnumerator();
   }
   ```

**Effort:** 4 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC001 (DdsSampleRef)

---

### FCDC-ZC004: Modify DdsReader.Read() Method

**Description:**  
Update `DdsReader<T>.Read()` to return non-generic `DdsLoan` instead of `DdsLoan<T>`. Remove unmarshaller reflection and delegate invocation.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 4.3](ZERO-COPY-READ-DESIGN.md#43-ddsreadert-runtime---modified)

**Files to Modify:**
- `src/CycloneDDS.Runtime/DdsReader.cs`

**Implementation Steps:**

1. **Remove Static Unmarshaller Field:**
   ```csharp
   // Remove:
   private static readonly NativeUnmarshalDelegate<T>? _unmarshaller;
   ```

2. **Update Static Constructor:**
   ```csharp
   static DdsReader()
   {
       // Remove unmarshaller reflection
       // Keep _nativeSizer and _nativeMarshaller (used for write ops if needed)
       
       var nativeSizeMethod = typeof(T).GetMethod("GetNativeSize", ...);
       if (nativeSizeMethod != null) 
           _nativeSizer = (GetNativeSizeDelegate)nativeSizeMethod.CreateDelegate(...);

       var toNativeMethod = typeof(T).GetMethod("MarshalToNative", ...);
       if (toNativeMethod != null) 
           _nativeMarshaller = (MarshalToNativeDelegate)toNativeMethod.CreateDelegate(...);
       
       var headSizeMethod = typeof(T).GetMethod("GetNativeHeadSize", ...);
       if (headSizeMethod != null) 
           _nativeHeadSize = (int)(headSizeMethod.Invoke(null, null) ?? 0);
   }
   ```

3. **Update Read() Method:**
   ```csharp
   public DdsLoan Read(int maxSamples = 32)
   {
       if (_readerHandle == null) 
           throw new ObjectDisposedException(nameof(DdsReader<T>));

       var samples = ArrayPool<IntPtr>.Shared.Rent(maxSamples);
       var infos = ArrayPool<DdsApi.DdsSampleInfo>.Shared.Rent(maxSamples);

       int count = DdsApi.dds_take(
           _readerHandle.NativeHandle.Handle,
           samples,
           infos,
           (uint)maxSamples,
           (uint)maxSamples
       );

       if (count < 0)
       {
           ArrayPool<IntPtr>.Shared.Return(samples);
           ArrayPool<DdsApi.DdsSampleInfo>.Shared.Return(infos);
           throw new DdsException($"dds_take failed: {count}");
       }

       return new DdsLoan(_readerHandle, samples, infos, count);
   }
   ```

4. **Remove Constructor Check:**
   ```csharp
   // Remove from constructor:
   // if (_unmarshaller == null)
   //     throw new InvalidOperationException(...);
   ```

**Success Criteria:**

1. **Return Type Test:**
   ```csharp
   [TestMethod]
   public void DdsReader_Read_ReturnsNonGenericLoan()
   {
       var reader = new DdsReader<TestType>(participant, "TestTopic");
       using (var loan = reader.Read())
       {
           // Verify type
           Assert.IsInstanceOfType(loan, typeof(DdsLoan));
       }
   }
   ```

2. **dds_take Integration Test:**
   ```csharp
   [TestMethod]
   public void DdsReader_Read_CallsDdsTake()
   {
       var reader = CreateTestReader();
       // Publish samples
       WriteTestSamples(10);
       
       using (var loan = reader.Read(10))
       {
           Assert.IsTrue(loan.Length > 0);
       }
   }
   ```

3. **Error Handling Test:**
   ```csharp
   [TestMethod]
   public void DdsReader_Read_ThrowsOnDdsTakeError()
   {
       var reader = CreateInvalidReader(); // Mock failure
       Assert.ThrowsException<DdsException>(() => reader.Read());
   }
   ```

**Effort:** 4 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC002, FCDC-ZC003

---

### FCDC-ZC005: Add Text Encoding Helper

**Description:**  
Add a utility method to `DdsTextEncoding` that creates a `ReadOnlySpan<byte>` over a null-terminated UTF-8 string pointer. This enables zero-allocation string access in views.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.4](ZERO-COPY-READ-DESIGN.md#54-helper-utilities)

**Files to Modify:**
- `src/CycloneDDS.Core/DdsTextEncoding.cs`

**Implementation:**

```csharp
namespace CycloneDDS.Core
{
    public static class DdsTextEncoding
    {
        // ... existing methods ...

        /// <summary>
        /// Creates a ReadOnlySpan over a null-terminated UTF-8 string.
        /// Does not allocate. Use Encoding.UTF8.GetString(span) to convert to string.
        /// </summary>
        /// <param name="ptr">Pointer to null-terminated UTF-8 string, or IntPtr.Zero for empty.</param>
        /// <returns>ReadOnlySpan over the UTF-8 bytes (excluding null terminator).</returns>
        public static unsafe ReadOnlySpan<byte> GetSpanFromPtr(IntPtr ptr)
        {
            if (ptr == IntPtr.Zero)
                return ReadOnlySpan<byte>.Empty;
            
            byte* p = (byte*)ptr;
            int length = 0;
            
            // Find null terminator
            while (p[length] != 0)
            {
                length++;
            }
            
            return new ReadOnlySpan<byte>(p, length);
        }
    }
}
```

**Success Criteria:**

1. **Null Pointer Test:**
   ```csharp
   [TestMethod]
   public void GetSpanFromPtr_NullPointer_ReturnsEmpty()
   {
       var span = DdsTextEncoding.GetSpanFromPtr(IntPtr.Zero);
       Assert.IsTrue(span.IsEmpty);
   }
   ```

2. **Valid String Test:**
   ```csharp
   [TestMethod]
   public unsafe void GetSpanFromPtr_ValidString_ReturnsCorrectSpan()
   {
       byte[] utf8 = Encoding.UTF8.GetBytes("Hello\0");
       fixed (byte* ptr = utf8)
       {
           var span = DdsTextEncoding.GetSpanFromPtr((IntPtr)ptr);
           Assert.AreEqual(5, span.Length);
           Assert.AreEqual((byte)'H', span[0]);
           Assert.AreEqual((byte)'o', span[4]);
       }
   }
   ```

3. **Zero Allocation Test:**
   ```csharp
   [TestMethod]
   public unsafe void GetSpanFromPtr_DoesNotAllocate()
   {
       byte[] utf8 = Encoding.UTF8.GetBytes("Test\0");
       fixed (byte* ptr = utf8)
       {
           long gen0Before = GC.CollectionCount(0);
           
           for (int i = 0; i < 1000; i++)
           {
               var span = DdsTextEncoding.GetSpanFromPtr((IntPtr)ptr);
               _ = span.Length;
           }
           
           long gen0After = GC.CollectionCount(0);
           Assert.AreEqual(0, gen0After - gen0Before);
       }
   }
   ```

4. **Unicode Test:**
   ```csharp
   [TestMethod]
   public unsafe void GetSpanFromPtr_Unicode_HandlesMultibyte()
   {
       string original = "Hello世界";
       byte[] utf8 = Encoding.UTF8.GetBytes(original + "\0");
       fixed (byte* ptr = utf8)
       {
           var span = DdsTextEncoding.GetSpanFromPtr((IntPtr)ptr);
           string decoded = Encoding.UTF8.GetString(span);
           Assert.AreEqual(original, decoded);
       }
   }
   ```

**Effort:** 2 hours  
**Priority:** P1 (High)  
**Dependencies:** None

---

## Phase 2: Code Generation - View Structs

**IMPORTANT:** View structs are a **third type** distinct from both DSL structs (user types) and Native structs (Ghost types). They are generated `ref struct` types that provide zero-copy read access to native memory. See the Architecture Overview section above for details.

### FCDC-ZC006: Create ViewStruct Emitter Infrastructure

**Description:**  
Add infrastructure to `DeserializerEmitter` (or create new `ViewEmitter` class) to generate `ref struct` view types (the third type in our architecture). Establish the basic skeleton and private pointer field.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.2](ZERO-COPY-READ-DESIGN.md#52-view-struct-generation)

**Files to Create/Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs` (new)
- Or extend `tools/CycloneDDS.CodeGen/Emitters/DeserializerEmitter.cs`

**Implementation:**

```csharp
public class ViewEmitter
{
    public void EmitViewStruct(StringBuilder sb, JsonTypeDefinition type, string namespaceName)
    {
        string viewName = $"{type.Name}View";
        string nativeType = $"{type.Name}_Native";

        sb.AppendLine($"namespace {namespaceName}");
        sb.AppendLine("{");
        
        // XML documentation
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Zero-copy view over native {type.Name} data.");
        sb.AppendLine("    /// Must be used within the scope of a DdsLoan (using statement).");
        sb.AppendLine("    /// </summary>");
        
        // Ref struct declaration
        sb.AppendLine($"    public ref struct {viewName}");
        sb.AppendLine("    {");
        
        // Private pointer field
        sb.AppendLine($"        private unsafe readonly {nativeType}* _ptr;");
        sb.AppendLine();
        
        // Internal constructor
        sb.AppendLine($"        internal unsafe {viewName}({nativeType}* ptr)");
        sb.AppendLine("        {");
        sb.AppendLine("            _ptr = ptr;");
        sb.AppendLine("        }");
        sb.AppendLine();
        
        // Properties will be added by other methods
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
    }
}
```

**Integration Point:**

```csharp
// In CodeGenDriver or main emit flow:
public void EmitAll(JsonTypeDefinition type)
{
    // ... existing emissions ...
    
    var viewEmitter = new ViewEmitter();
    viewEmitter.EmitViewStruct(sb, type, namespaceName);
}
```

**Success Criteria:**

1. **Generated Code Compiles:**
   ```csharp
   [TestMethod]
   public void ViewEmitter_EmitViewStruct_GeneratesCompilableCode()
   {
       var type = new JsonTypeDefinition 
       { 
           Name = "TestType",
           Members = new List<JsonMemberDefinition>()
       };
       
       var sb = new StringBuilder();
       var emitter = new ViewEmitter();
       emitter.EmitViewStruct(sb, type, "TestNamespace");
       
       string code = sb.ToString();
       
       // Verify contains ref struct declaration
       Assert.IsTrue(code.Contains("public ref struct TestTypeView"));
       Assert.IsTrue(code.Contains("private unsafe readonly TestType_Native* _ptr"));
       Assert.IsTrue(code.Contains("internal unsafe TestTypeView(TestType_Native* ptr)"));
   }
   ```

2. **Integration Test:**
   ```csharp
   [TestMethod]
   public void CodeGen_GenerateViewForSimpleType_Compiles()
   {
       string idl = @"
           module Test {
               struct SimpleType {
                   long id;
               };
           };
       ";
       
       var generatedCode = RunCodeGen(idl);
       var compilation = CompileCode(generatedCode);
       
       Assert.IsFalse(compilation.GetDiagnostics().Any(d => d.Severity == DiagnosticSeverity.Error));
   }
   ```

**Effort:** 6 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** Phase 1 complete

---

### FCDC-ZC007: Emit Primitive Field Accessors

**Description:**  
Generate properties for primitive fields (int, uint, long, ulong, float, double, bool, byte, etc.) that perform direct pointer dereference.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 1](ZERO-COPY-READ-DESIGN.md#rule-1-primitives-int-uint-double-bool-etc)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitPrimitiveProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;
    string csType = MapDdsTypeToCSharp(member.Type);

    sb.AppendLine($"        /// <summary>Gets the {member.Name} field.</summary>");
    sb.AppendLine($"        public {csType} {propName}");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                unsafe {{ return _ptr->{fieldName}; }}");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Type Mapping:**
```csharp
private string MapDdsTypeToCSharp(string ddsType)
{
    return ddsType switch
    {
        "int8" => "sbyte",
        "uint8" => "byte",
        "int16" => "short",
        "uint16" => "ushort",
        "int32" => "int",
        "uint32" => "uint",
        "int64" => "long",
        "uint64" => "ulong",
        "float32" => "float",
        "float64" => "double",
        "boolean" => "bool",
        "char" => "byte", // IDL char is 8-bit
        _ => throw new NotSupportedException($"Unsupported primitive type: {ddsType}")
    };
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitPrimitiveProperty_Uint32_GeneratesCorrectCode()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "id", 
           Type = "uint32" 
       };
       
       var sb = new StringBuilder();
       EmitPrimitiveProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public uint Id"));
       Assert.IsTrue(code.Contains("return _ptr->id"));
   }
   ```

2. **Runtime Access Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_Id_ReturnsCorrectValue()
   {
       var native = new TestType_Native { id = 42 };
       var view = new TestTypeView(&native);
       
       Assert.AreEqual(42u, view.Id);
   }
   ```

3. **All Primitive Types Test:**
   ```csharp
   [TestMethod]
   public void AllPrimitiveTypes_Compile_And_Work()
   {
       // Test all: int8, uint8, int16, uint16, int32, uint32, int64, uint64, float, double, bool
       // Generate code for each, compile, and verify runtime access
   }
   ```

**Effort:** 4 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC006

---

### FCDC-ZC008: Emit String Field Accessors

**Description:**  
Generate two properties for string fields: one returning `ReadOnlySpan<byte>` (zero-alloc) and one returning `string?` (allocating).

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 2](ZERO-COPY-READ-DESIGN.md#rule-2-strings)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitStringProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;

    // Zero-alloc accessor (Raw)
    sb.AppendLine($"        /// <summary>Gets {member.Name} as UTF-8 bytes (zero-copy).</summary>");
    sb.AppendLine($"        public unsafe ReadOnlySpan<byte> {propName}Raw");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                return DdsTextEncoding.GetSpanFromPtr(_ptr->{fieldName});");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();

    // Allocating accessor (string)
    sb.AppendLine($"        /// <summary>Gets {member.Name} as C# string (allocates).</summary>");
    sb.AppendLine($"        public string? {propName}");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                unsafe {{ return DdsTextEncoding.FromNativeUtf8(_ptr->{fieldName}); }}");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitStringProperty_GeneratesBothAccessors()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "name", 
           Type = "string" 
       };
       
       var sb = new StringBuilder();
       EmitStringProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public unsafe ReadOnlySpan<byte> NameRaw"));
       Assert.IsTrue(code.Contains("public string? Name"));
   }
   ```

2. **Zero-Alloc Accessor Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_NameRaw_ReturnsSpan_NoAlloc()
   {
       byte[] utf8 = Encoding.UTF8.GetBytes("TestString\0");
       fixed (byte* ptr = utf8)
       {
           var native = new TestType_Native { name = (IntPtr)ptr };
           var view = new TestTypeView(&native);
           
           long gen0Before = GC.CollectionCount(0);
           var span = view.NameRaw;
           long gen0After = GC.CollectionCount(0);
           
           Assert.AreEqual(0, gen0After - gen0Before);
           Assert.AreEqual("TestString", Encoding.UTF8.GetString(span));
       }
   }
   ```

3. **Allocating Accessor Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_Name_ReturnsString()
   {
       byte[] utf8 = Encoding.UTF8.GetBytes("TestString\0");
       fixed (byte* ptr = utf8)
       {
           var native = new TestType_Native { name = (IntPtr)ptr };
           var view = new TestTypeView(&native);
           
           Assert.AreEqual("TestString", view.Name);
       }
   }
   ```

4. **Null String Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_NullString_ReturnsEmpty()
   {
       var native = new TestType_Native { name = IntPtr.Zero };
       var view = new TestTypeView(&native);
       
       Assert.IsTrue(view.NameRaw.IsEmpty);
       Assert.IsNull(view.Name);
   }
   ```

**Effort:** 4 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC005, FCDC-ZC006

---

### FCDC-ZC009: Emit Primitive Sequence Accessors

**Description:**  
Generate properties for sequences of primitives (e.g., `sequence<double>`) that return `ReadOnlySpan<T>` providing direct zero-copy access to the native array.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 3](ZERO-COPY-READ-DESIGN.md#rule-3-primitive-sequences)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitPrimitiveSequenceProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;
    string elementType = MapDdsTypeToCSharp(member.Type);

    sb.AppendLine($"        /// <summary>Gets {member.Name} as ReadOnlySpan (zero-copy).</summary>");
    sb.AppendLine($"        public unsafe ReadOnlySpan<{elementType}> {propName}");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                return new ReadOnlySpan<{elementType}>(");
    sb.AppendLine($"                    (void*)_ptr->{fieldName}.Buffer,");
    sb.AppendLine($"                    (int)_ptr->{fieldName}.Length");
    sb.AppendLine("                );");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitPrimitiveSequenceProperty_GeneratesSpanAccessor()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "values", 
           Type = "double",
           CollectionType = "sequence"
       };
       
       var sb = new StringBuilder();
       EmitPrimitiveSequenceProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public unsafe ReadOnlySpan<double> Values"));
   }
   ```

2. **Runtime Access Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_Values_ReturnsCorrectSpan()
   {
       double[] data = { 1.1, 2.2, 3.3 };
       fixed (double* ptr = data)
       {
           var native = new TestType_Native
           {
               values = new DdsSequenceNative
               {
                   Buffer = (IntPtr)ptr,
                   Length = 3,
                   Maximum = 3,
                   Release = 0
               }
           };
           
           var view = new TestTypeView(&native);
           var span = view.Values;
           
           Assert.AreEqual(3, span.Length);
           Assert.AreEqual(1.1, span[0]);
           Assert.AreEqual(3.3, span[2]);
       }
   }
   ```

3. **Empty Sequence Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_EmptySequence_ReturnsEmptySpan()
   {
       var native = new TestType_Native
       {
           values = new DdsSequenceNative
           {
               Buffer = IntPtr.Zero,
               Length = 0,
               Maximum = 0,
               Release = 0
           }
       };
       
       var view = new TestTypeView(&native);
       Assert.IsTrue(view.Values.IsEmpty);
   }
   ```

**Effort:** 4 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC006

---

### FCDC-ZC010: Emit Struct Sequence Accessors

**Description:**  
Generate indexer-style accessors for sequences of structs (e.g., `sequence<Point3D>`). Cannot use `Span<View>` due to nested ref structs limitation, so provide count property and `Get{Name}(int index)` method.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 5](ZERO-COPY-READ-DESIGN.md#rule-5-struct-sequences)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitStructSequenceProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;
    string elementView = $"{member.Type}View";
    string elementNative = $"{member.Type}_Native";

    // Count property
    sb.AppendLine($"        /// <summary>Gets the number of {member.Name} elements.</summary>");
    sb.AppendLine($"        public int {propName}Count");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                unsafe {{ return (int)_ptr->{fieldName}.Length; }}");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();

    // Indexer method
    sb.AppendLine($"        /// <summary>Gets {member.Name} element at specified index.</summary>");
    sb.AppendLine($"        public unsafe {elementView} Get{propName}(int index)");
    sb.AppendLine("        {");
    sb.AppendLine($"            if (index < 0 || index >= {propName}Count)");
    sb.AppendLine("                throw new ArgumentOutOfRangeException(nameof(index));");
    sb.AppendLine();
    sb.AppendLine($"            {elementNative}* arr = ({elementNative}*)_ptr->{fieldName}.Buffer;");
    sb.AppendLine($"            return new {elementView}(&arr[index]);");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitStructSequenceProperty_GeneratesCountAndIndexer()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "points", 
           Type = "Point3D",
           CollectionType = "sequence"
       };
       
       var sb = new StringBuilder();
       EmitStructSequenceProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public int PointsCount"));
       Assert.IsTrue(code.Contains("public unsafe Point3DView GetPoints(int index)"));
   }
   ```

2. **Runtime Access Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_GetPoints_ReturnsCorrectViews()
   {
       var data = new Point3D_Native[]
       {
           new Point3D_Native { x = 1.0, y = 2.0, z = 3.0 },
           new Point3D_Native { x = 4.0, y = 5.0, z = 6.0 }
       };
       
       fixed (Point3D_Native* ptr = data)
       {
           var native = new TestType_Native
           {
               points = new DdsSequenceNative
               {
                   Buffer = (IntPtr)ptr,
                   Length = 2,
                   Maximum = 2,
                   Release = 0
               }
           };
           
           var view = new TestTypeView(&native);
           
           Assert.AreEqual(2, view.PointsCount);
           
           var point0 = view.GetPoints(0);
           Assert.AreEqual(1.0, point0.X);
           Assert.AreEqual(2.0, point0.Y);
           
           var point1 = view.GetPoints(1);
           Assert.AreEqual(4.0, point1.X);
       }
   }
   ```

3. **Bounds Check Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_GetPoints_OutOfBounds_Throws()
   {
       var native = CreateNativeWithEmptyPointsSequence();
       var view = new TestTypeView(&native);
       
       Assert.ThrowsException<ArgumentOutOfRangeException>(() => view.GetPoints(0));
       Assert.ThrowsException<ArgumentOutOfRangeException>(() => view.GetPoints(-1));
   }
   ```

**Effort:** 6 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC006

---

### FCDC-ZC011: Emit String Sequence Accessors

**Description:**  
Generate indexer-style accessors for sequences of strings (e.g., `sequence<string>`). Provide count property and both zero-alloc (`Get{Name}Raw`) and allocating (`Get{Name}`) indexers.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 4](ZERO-COPY-READ-DESIGN.md#rule-4-string-sequences)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitStringSequenceProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;

    // Count property
    sb.AppendLine($"        /// <summary>Gets the number of {member.Name} elements.</summary>");
    sb.AppendLine($"        public int {propName}Count");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                unsafe {{ return (int)_ptr->{fieldName}.Length; }}");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();

    // Zero-alloc indexer (Raw)
    sb.AppendLine($"        /// <summary>Gets {member.Name} element at index as UTF-8 bytes (zero-copy).</summary>");
    sb.AppendLine($"        public unsafe ReadOnlySpan<byte> Get{propName}Raw(int index)");
    sb.AppendLine("        {");
    sb.AppendLine($"            if (index < 0 || index >= {propName}Count)");
    sb.AppendLine("                throw new ArgumentOutOfRangeException(nameof(index));");
    sb.AppendLine();
    sb.AppendLine($"            IntPtr* ptrArray = (IntPtr*)_ptr->{fieldName}.Buffer;");
    sb.AppendLine("            return DdsTextEncoding.GetSpanFromPtr(ptrArray[index]);");
    sb.AppendLine("        }");
    sb.AppendLine();

    // Allocating indexer (string)
    sb.AppendLine($"        /// <summary>Gets {member.Name} element at index as C# string (allocates).</summary>");
    sb.AppendLine($"        public unsafe string? Get{propName}(int index)");
    sb.AppendLine("        {");
    sb.AppendLine($"            if (index < 0 || index >= {propName}Count)");
    sb.AppendLine("                throw new ArgumentOutOfRangeException(nameof(index));");
    sb.AppendLine();
    sb.AppendLine($"            IntPtr* ptrArray = (IntPtr*)_ptr->{fieldName}.Buffer;");
    sb.AppendLine("            return DdsTextEncoding.FromNativeUtf8(ptrArray[index]);");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitStringSequenceProperty_GeneratesCountAndBothIndexers()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "messages", 
           Type = "string",
           CollectionType = "sequence"
       };
       
       var sb = new StringBuilder();
       EmitStringSequenceProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public int MessagesCount"));
       Assert.IsTrue(code.Contains("public unsafe ReadOnlySpan<byte> GetMessagesRaw(int index)"));
       Assert.IsTrue(code.Contains("public unsafe string? GetMessages(int index)"));
   }
   ```

2. **Runtime Access Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_GetMessages_ReturnsCorrectStrings()
   {
       byte[] str0 = Encoding.UTF8.GetBytes("Hello\0");
       byte[] str1 = Encoding.UTF8.GetBytes("World\0");
       
       fixed (byte* ptr0 = str0, ptr1 = str1)
       {
           IntPtr[] ptrArray = { (IntPtr)ptr0, (IntPtr)ptr1 };
           fixed (IntPtr* arrPtr = ptrArray)
           {
               var native = new TestType_Native
               {
                   messages = new DdsSequenceNative
                   {
                       Buffer = (IntPtr)arrPtr,
                       Length = 2,
                       Maximum = 2,
                       Release = 0
                   }
               };
               
               var view = new TestTypeView(&native);
               
               Assert.AreEqual(2, view.MessagesCount);
               Assert.AreEqual("Hello", view.GetMessages(0));
               Assert.AreEqual("World", view.GetMessages(1));
           }
       }
   }
   ```

3. **Zero-Alloc Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_GetMessagesRaw_NoAlloc()
   {
       // Setup same as above
       
       long gen0Before = GC.CollectionCount(0);
       
       var span0 = view.GetMessagesRaw(0);
       var span1 = view.GetMessagesRaw(1);
       
       long gen0After = GC.CollectionCount(0);
       
       Assert.AreEqual(0, gen0After - gen0Before);
       Assert.AreEqual("Hello", Encoding.UTF8.GetString(span0));
   }
   ```

**Effort:** 6 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC005, FCDC-ZC006

---

### FCDC-ZC012: Emit Fixed Array Accessors

**Description:**  
Generate properties for fixed-size arrays (e.g., `double matrix[12]`) that return `ReadOnlySpan<T>` providing zero-copy access.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 6](ZERO-COPY-READ-DESIGN.md#rule-6-fixed-arrays)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitFixedArrayProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;
    string elementType = MapDdsTypeToCSharp(member.Type);
    int totalLength = member.Dimensions.Aggregate(1, (a, b) => a * b);

    sb.AppendLine($"        /// <summary>Gets {member.Name} as ReadOnlySpan (zero-copy).</summary>");
    sb.AppendLine($"        public unsafe ReadOnlySpan<{elementType}> {propName}");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                fixed ({elementType}* ptr = _ptr->{fieldName})");
    sb.AppendLine("                {");
    sb.AppendLine($"                    return new ReadOnlySpan<{elementType}>(ptr, {totalLength});");
    sb.AppendLine("                }");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitFixedArrayProperty_MultidimensionalArray_Flattens()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "matrix", 
           Type = "double",
           Dimensions = new List<int> { 3, 4 } // [3][4] → 12
       };
       
       var sb = new StringBuilder();
       EmitFixedArrayProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public unsafe ReadOnlySpan<double> Matrix"));
       Assert.IsTrue(code.Contains("return new ReadOnlySpan<double>(ptr, 12)"));
   }
   ```

2. **Runtime Access Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_Matrix_ReturnsCorrectSpan()
   {
       var native = new TestType_Native();
       // Set matrix[0..11]
       native.matrix[0] = 1.0;
       native.matrix[5] = 5.0;
       native.matrix[11] = 11.0;
       
       var view = new TestTypeView(&native);
       var span = view.Matrix;
       
       Assert.AreEqual(12, span.Length);
       Assert.AreEqual(1.0, span[0]);
       Assert.AreEqual(5.0, span[5]);
       Assert.AreEqual(11.0, span[11]);
   }
   ```

3. **1D Array Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_Array1D_Works()
   {
       // Test: double values[10];
       var member = new JsonMemberDefinition 
       { 
           Name = "values", 
           Type = "double",
           Dimensions = new List<int> { 10 }
       };
       
       // Generate and verify
   }
   ```

**Effort:** 4 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC006, FCDC-ZC019 (array flattening fix)

---

### FCDC-ZC013: Emit Union Accessors

**Description:**  
Generate properties for union types, providing discriminator access and typed accessors that return nullable values based on the active discriminator.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3 Rule 7](ZERO-COPY-READ-DESIGN.md#rule-7-unions)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitUnionProperty(StringBuilder sb, JsonTypeDefinition unionType, string memberName)
{
    string propName = ToPascalCase(memberName);
    string fieldName = memberName;
    string discriminatorEnum = $"{unionType.Name}Discriminator";

    // Discriminator accessor
    sb.AppendLine($"        /// <summary>Gets the discriminator for {memberName}.</summary>");
    sb.AppendLine($"        public {discriminatorEnum} {propName}Kind");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                unsafe {{ return ({discriminatorEnum})_ptr->{fieldName}._d; }}");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();

    // Typed accessors for each case
    foreach (var member in unionType.Members)
    {
        string caseName = ToPascalCase(member.Name);
        string caseType = MapDdsTypeToCSharp(member.Type);
        string caseField = member.Name;

        sb.AppendLine($"        /// <summary>Gets {memberName} as {caseType} if discriminator matches.</summary>");
        sb.AppendLine($"        public {caseType}? {propName}As{caseName}");
        sb.AppendLine("        {");
        sb.AppendLine("            get");
        sb.AppendLine("            {");
        sb.AppendLine($"                unsafe");
        sb.AppendLine("                {");
        sb.AppendLine($"                    return {propName}Kind == {discriminatorEnum}.{caseName}");
        sb.AppendLine($"                        ? ({caseType}?)_ptr->{fieldName}.{caseField}");
        sb.AppendLine("                        : null;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitUnionProperty_GeneratesDiscriminatorAndCaseAccessors()
   {
       var unionType = new JsonTypeDefinition
       {
           Name = "MyUnion",
           Kind = "union",
           Members = new List<JsonMemberDefinition>
           {
               new JsonMemberDefinition { Name = "int_value", Type = "int32" },
               new JsonMemberDefinition { Name = "double_value", Type = "double" }
           }
       };
       
       var sb = new StringBuilder();
       EmitUnionProperty(sb, unionType, "value");
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public MyUnionDiscriminator ValueKind"));
       Assert.IsTrue(code.Contains("public int? ValueAsIntValue"));
       Assert.IsTrue(code.Contains("public double? ValueAsDoubleValue"));
   }
   ```

2. **Runtime Access Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_UnionAccess_ReturnsCorrectCase()
   {
       var native = new TestType_Native
       {
           value = new MyUnion_Native
           {
               _d = (int)MyUnionDiscriminator.IntValue,
               int_value = 42
           }
       };
       
       var view = new TestTypeView(&native);
       
       Assert.AreEqual(MyUnionDiscriminator.IntValue, view.ValueKind);
       Assert.AreEqual(42, view.ValueAsIntValue);
       Assert.IsNull(view.ValueAsDoubleValue);
   }
   ```

**Effort:** 6 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC006

---

### FCDC-ZC014: Emit Optional Field Accessors

**Description:**  
Generate properties for optional fields (IDL4 `@optional`) that check for null pointers before accessing.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 8.4](ZERO-COPY-READ-DESIGN.md#84-optional-members-idl4)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
private void EmitOptionalProperty(StringBuilder sb, JsonMemberDefinition member)
{
    string propName = ToPascalCase(member.Name);
    string fieldName = member.Name;
    string csType = MapDdsTypeToCSharp(member.Type);

    // Has{Field} property
    sb.AppendLine($"        /// <summary>Gets whether {member.Name} is present.</summary>");
    sb.AppendLine($"        public bool Has{propName}");
    sb.AppendLine("        {");
    sb.AppendLine("            get");
    sb.AppendLine("            {");
    sb.AppendLine($"                unsafe {{ return _ptr->{fieldName} != IntPtr.Zero; }}");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    sb.AppendLine();

    // Accessor (type-specific)
    if (member.Type == "string")
    {
        sb.AppendLine($"        /// <summary>Gets {member.Name} value (null if absent).</summary>");
        sb.AppendLine($"        public string? {propName}");
        sb.AppendLine("        {");
        sb.AppendLine("            get");
        sb.AppendLine("            {");
        sb.AppendLine($"                unsafe");
        sb.AppendLine("                {");
        sb.AppendLine($"                    return _ptr->{fieldName} != IntPtr.Zero");
        sb.AppendLine($"                        ? DdsTextEncoding.FromNativeUtf8(_ptr->{fieldName})");
        sb.AppendLine("                        : null;");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }
    else
    {
        // For primitives stored via pointer
        sb.AppendLine($"        /// <summary>Gets {member.Name} value (null if absent).</summary>");
        sb.AppendLine($"        public {csType}? {propName}");
        sb.AppendLine("        {");
        sb.AppendLine("            get");
        sb.AppendLine("            {");
        sb.AppendLine($"                unsafe");
        sb.AppendLine("                {");
        sb.AppendLine($"                    if (_ptr->{fieldName} == IntPtr.Zero) return null;");
        sb.AppendLine($"                    return *({csType}*)_ptr->{fieldName};");
        sb.AppendLine("                }");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
    }
    sb.AppendLine();
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitOptionalProperty_GeneratesHasAndAccessor()
   {
       var member = new JsonMemberDefinition 
       { 
           Name = "description", 
           Type = "string",
           IsOptional = true
       };
       
       var sb = new StringBuilder();
       EmitOptionalProperty(sb, member);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public bool HasDescription"));
       Assert.IsTrue(code.Contains("public string? Description"));
   }
   ```

2. **Present Value Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_OptionalField_Present_ReturnsValue()
   {
       byte[] utf8 = Encoding.UTF8.GetBytes("Description\0");
       fixed (byte* ptr = utf8)
       {
           var native = new TestType_Native { description = (IntPtr)ptr };
           var view = new TestTypeView(&native);
           
           Assert.IsTrue(view.HasDescription);
           Assert.AreEqual("Description", view.Description);
       }
   }
   ```

3. **Absent Value Test:**
   ```csharp
   [TestMethod]
   public unsafe void TestTypeView_OptionalField_Absent_ReturnsNull()
   {
       var native = new TestType_Native { description = IntPtr.Zero };
       var view = new TestTypeView(&native);
       
       Assert.IsFalse(view.HasDescription);
       Assert.IsNull(view.Description);
   }
   ```

**Effort:** 4 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC006

---

## Phase 3: Code Generation - Extension Methods

### FCDC-ZC015: Create Extension Method Emitter

**Description:**  
Generate static extension class with `AsView()` method that performs unsafe cast from `DdsSampleRef` to the typed view struct.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 5.3](ZERO-COPY-READ-DESIGN.md#53-code-generation-rules)

**Files to Create/Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**Implementation:**

```csharp
public void EmitExtensionMethod(StringBuilder sb, JsonTypeDefinition type, string namespaceName)
{
    string typeName = type.Name;
    string viewName = $"{typeName}View";
    string nativeName = $"{typeName}_Native";

    sb.AppendLine($"namespace {namespaceName}");
    sb.AppendLine("{");
    
    sb.AppendLine("    /// <summary>");
    sb.AppendLine($"    /// Extension methods for {typeName}.");
    sb.AppendLine("    /// </summary>");
    sb.AppendLine($"    public static class {typeName}Extensions");
    sb.AppendLine("    {");
    
    sb.AppendLine("        /// <summary>");
    sb.AppendLine($"        /// Casts a DdsSampleRef to a {viewName}.");
    sb.AppendLine("        /// The sample must have valid data (check sample.IsValid first).");
    sb.AppendLine("        /// </summary>");
    sb.AppendLine($"        public static {viewName} AsView(this CycloneDDS.Runtime.DdsSampleRef sample)");
    sb.AppendLine("        {");
    sb.AppendLine("            unsafe");
    sb.AppendLine("            {");
    sb.AppendLine($"                return new {viewName}(({nativeName}*)sample.DataPtr);");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
    
    sb.AppendLine("    }");
    sb.AppendLine("}");
}
```

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitExtensionMethod_GeneratesCorrectCode()
   {
       var type = new JsonTypeDefinition { Name = "TestType" };
       var sb = new StringBuilder();
       
       var emitter = new ViewEmitter();
       emitter.EmitExtensionMethod(sb, type, "TestNamespace");
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public static class TestTypeExtensions"));
       Assert.IsTrue(code.Contains("public static TestTypeView AsView(this CycloneDDS.Runtime.DdsSampleRef sample)"));
       Assert.IsTrue(code.Contains("return new TestTypeView((TestType_Native*)sample.DataPtr)"));
   }
   ```

2. **Compilation Test:**
   ```csharp
   [TestMethod]
   public void ExtensionMethod_Compiles_AndWorks()
   {
       string generatedCode = GenerateFullCodeForTestType();
       var compilation = CompileCode(generatedCode);
       
       Assert.IsFalse(compilation.GetDiagnostics().Any(d => d.Severity == DiagnosticSeverity.Error));
   }
   ```

3. **Usage Test:**
   ```csharp
   [TestMethod]
   public unsafe void ExtensionMethod_AsView_ReturnsCorrectView()
   {
       var native = new TestType_Native { id = 42 };
       var info = new DdsApi.DdsSampleInfo { ValidData = 1 };
       var sampleRef = new DdsSampleRef((IntPtr)(&native), ref info);
       
       // Call extension method
       var view = sampleRef.AsView();
       
       Assert.AreEqual(42u, view.Id);
   }
   ```

**Effort:** 3 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** FCDC-ZC006

---

### FCDC-ZC016: Verify Extension Method Inlining

**Description:**  
Verify that the compiler inlines the `AsView()` extension method to ensure zero runtime overhead.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 3.3](ZERO-COPY-READ-DESIGN.md#33-the-extension-method-pattern)

**Files:** N/A (verification task)

**Procedure:**

1. **Build in Release Mode:**
   ```bash
   dotnet build -c Release
   ```

2. **Use BenchmarkDotNet:**
   ```csharp
   [Benchmark]
   public uint DirectPointerAccess()
   {
       unsafe
       {
           var native = new TestType_Native { id = 42 };
           var view = new TestTypeView(&native);
           return view.Id;
       }
   }

   [Benchmark]
   public uint ViaExtensionMethod()
   {
       unsafe
       {
           var native = new TestType_Native { id = 42 };
           var info = new DdsApi.DdsSampleInfo { ValidData = 1 };
           var sampleRef = new DdsSampleRef((IntPtr)(&native), ref info);
           var view = sampleRef.AsView();
           return view.Id;
       }
   }
   ```

3. **Compare Results:**
   - Both benchmarks should have identical performance
   - Verify no delegate allocation in extension method path

4. **Disassembly Inspection (Optional):**
   ```bash
   dotnet run -c Release
   # Use dnSpy, ILSpy, or dotnet-disasm to view JIT assembly
   ```

**Success Criteria:**

1. **Performance Equality:**
   ```csharp
   [TestMethod]
   public void AsView_Performance_MatchesDirectAccess()
   {
       var summary = BenchmarkRunner.Run<ViewBenchmarks>();
       
       var directTime = summary.Reports
           .First(r => r.BenchmarkCase.Descriptor.WorkloadMethod.Name == "DirectPointerAccess")
           .ResultStatistics.Mean;
       
       var extensionTime = summary.Reports
           .First(r => r.BenchmarkCase.Descriptor.WorkloadMethod.Name == "ViaExtensionMethod")
           .ResultStatistics.Mean;
       
       // Should be within 5% (accounts for measurement noise)
       Assert.IsTrue(Math.Abs(extensionTime - directTime) / directTime < 0.05);
   }
   ```

2. **Zero Allocation Verification:**
   ```csharp
   [TestMethod]
   public void AsView_AllocatesNothing()
   {
       unsafe
       {
           var native = new TestType_Native { id = 42 };
           var info = new DdsApi.DdsSampleInfo { ValidData = 1 };
           
           long gen0Before = GC.CollectionCount(0);
           
           for (int i = 0; i < 10000; i++)
           {
               var sampleRef = new DdsSampleRef((IntPtr)(&native), ref info);
               var view = sampleRef.AsView();
               _ = view.Id;
           }
           
           long gen0After = GC.CollectionCount(0);
           Assert.AreEqual(0, gen0After - gen0Before);
       }
   }
   ```

**Effort:** 4 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC015

---

## Phase 4: Code Generation - ToManaged

### FCDC-ZC017: Create ToManaged Emitter

**Description:**  
Generate `ToManaged()` method on view structs that deep-copies native data to managed C# DSL objects. This bridges Path 1 (zero-copy View access) with Path 2 (managed DSL persistence). The View (third type) is converted to the DSL type (user type), allocating heap memory for strings and collections.

**CRITICAL:** Also refactor existing `MarshalFromNative` in DSL structs to delegate to the new View-based implementation, avoiding duplicate deep-copy logic (see Gap 1 in design doc).

**Reference:** [ZERO-COPY-READ-DESIGN.md § 6.3](ZERO-COPY-READ-DESIGN.md#63-tomanaged-generation), [§ 11.0 Code Generation Conflicts](ZERO-COPY-READ-DESIGN.md#110-addressing-code-generation-conflicts)

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs` (add ToManaged generation)
- `tools/CycloneDDS.CodeGen/Emitters/DeserializerEmitter.cs` (refactor EmitUnmarshalFromNative to delegate)

**Implementation:**

**Part 1: Generate ToManaged() on View Struct**

```csharp
public void EmitToManagedMethod(StringBuilder sb, JsonTypeDefinition type)
{
    string typeName = type.Name;

    sb.AppendLine("        /// <summary>");
    sb.AppendLine("        /// Creates a managed copy of this view.");
    sb.AppendLine("        /// WARNING: This allocates on the heap. Use only when persistence is needed.");
    sb.AppendLine("        /// </summary>");
    sb.AppendLine($"        public {typeName} ToManaged()");
    sb.AppendLine("        {");
    sb.AppendLine($"            return new {typeName}");
    sb.AppendLine("            {");

    foreach (var member in type.Members)
    {
        string propName = ToPascalCase(member.Name);

        if (IsPrimitive(member.Type) && member.CollectionType == null)
        {
            // Primitive field
            sb.AppendLine($"                {propName} = this.{propName},");
        }
        else if (member.Type == "string" && member.CollectionType == null)
        {
            // String field
            sb.AppendLine($"                {propName} = this.{propName}, // Allocates");
        }
        else if (member.CollectionType == "sequence" && IsPrimitive(member.Type))
        {
            // Primitive sequence
            sb.AppendLine($"                {propName} = this.{propName}.ToArray(), // Allocates");
        }
        else if (member.CollectionType == "sequence" && member.Type == "string")
        {
            // String sequence
            sb.AppendLine($"                {propName} = Enumerable.Range(0, this.{propName}Count)");
            sb.AppendLine($"                    .Select(i => this.Get{propName}(i))");
            sb.AppendLine("                    .ToList(), // Allocates");
        }
        else if (member.CollectionType == "sequence")
        {
            // Struct sequence
            sb.AppendLine($"                {propName} = Enumerable.Range(0, this.{propName}Count)");
            sb.AppendLine($"                    .Select(i => this.Get{propName}(i).ToManaged())");
            sb.AppendLine("                    .ToList(), // Allocates");
        }
        // ... handle fixed arrays, unions, etc.
    }

    sb.AppendLine("            };");
    sb.AppendLine("        }");
    sb.AppendLine();
}
```

**Part 2: Refactor MarshalFromNative in DSL Struct (Gap 1 Fix)**

```csharp
// In DeserializerEmitter.cs
public void EmitUnmarshalFromNative(StringBuilder sb, JsonTypeDefinition type)
{
    string typeName = type.Name;
    string nativeTypeName = $"{typeName}_Native";
    string viewTypeName = $"{typeName}View";

    sb.AppendLine("        /// <summary>");
    sb.AppendLine("        /// Deep-copies native data to managed object.");
    sb.AppendLine("        /// </summary>");
    sb.AppendLine("        [Obsolete(\"Use AsView().ToManaged() for explicit control over allocation.\")]");
    sb.AppendLine($"        internal static {typeName} MarshalFromNative(IntPtr ptr)");
    sb.AppendLine("        {");
    sb.AppendLine("            if (ptr == IntPtr.Zero) return null;");
    sb.AppendLine("            unsafe");
    sb.AppendLine("            {");
    sb.AppendLine($"                return new {viewTypeName}(({nativeTypeName}*)ptr).ToManaged();");
    sb.AppendLine("            }");
    sb.AppendLine("        }");
}
```

**Benefits:**
- ✅ Single source of truth for deep-copy logic (in View.ToManaged())
- ✅ Backward compatibility with existing `DdsLoan<T>` unmarshaller
- ✅ Clear deprecation path for future API simplification

**Success Criteria:**

1. **Code Generation Test:**
   ```csharp
   [TestMethod]
   public void EmitToManagedMethod_GeneratesCompleteMethod()
   {
       var type = CreateTestTypeDefinition();
       var sb = new StringBuilder();
       
       var emitter = new ViewEmitter();
       emitter.EmitToManagedMethod(sb, type);
       
       string code = sb.ToString();
       Assert.IsTrue(code.Contains("public TestType ToManaged()"));
       Assert.IsTrue(code.Contains("return new TestType"));
   }
   ```

2. **Round-Trip Test:**
   ```csharp
   [TestMethod]
   public unsafe void ToManaged_RoundTrip_PreservesData()
   {
       // Create native struct with known data
       var original = CreateTestNativeStruct();
       var view = new TestTypeView(&original);
       
       // Convert to managed
       var managed = view.ToManaged();
       
       // Verify all fields match
       Assert.AreEqual(view.Id, managed.Id);
       Assert.AreEqual(view.Name, managed.Name);
       CollectionAssert.AreEqual(view.Values.ToArray(), managed.Values);
   }
   ```

3. **Nested Struct Test:**
   ```csharp
   [TestMethod]
   public unsafe void ToManaged_NestedStructs_DeepCopies()
   {
       // Test recursive ToManaged() calls
   }
   ```

**Effort:** 8 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC006

---

### FCDC-ZC018: Implement ReadCopied Extension

**Description:**  
Create convenience extension method `ReadCopied()` that performs allocating reads for backwards compatibility.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 6.2](ZERO-COPY-READ-DESIGN.md#62-convenience-api-backwards-compatibility)

**Files to Create:**
- `src/CycloneDDS.Runtime/Extensions/DdsReaderCompatExtensions.cs`

**Implementation:**

```csharp
using System.Collections.Generic;

namespace CycloneDDS.Runtime.Extensions
{
    /// <summary>
    /// Compatibility extensions for DdsReader providing allocating read methods.
    /// </summary>
    public static class DdsReaderCompatExtensions
    {
        /// <summary>
        /// Reads and copies samples to managed objects (allocating).
        /// Provided for backwards compatibility and convenience.
        /// For high performance, use Read() with zero-copy views instead.
        /// </summary>
        public static List<T> ReadCopied<T>(
            this DdsReader<T> reader,
            int maxSamples = 32) where T : struct
        {
            var result = new List<T>();
            
            using (var loan = reader.Read(maxSamples))
            {
                foreach (var sample in loan)
                {
                    if (sample.IsValid)
                    {
                        // Uses generated AsView() and ToManaged()
                        var view = sample.AsView();
                        var managed = view.ToManaged();
                        result.Add(managed);
                    }
                }
            }
            
            return result;
        }

        /// <summary>
        /// Reads samples and invokes callback for each valid sample (allocating).
        /// </summary>
        public static void ReadForEach<T>(
            this DdsReader<T> reader,
            Action<T> action,
            int maxSamples = 32) where T : struct
        {
            using (var loan = reader.Read(maxSamples))
            {
                foreach (var sample in loan)
                {
                    if (sample.IsValid)
                    {
                        var view = sample.AsView();
                        var managed = view.ToManaged();
                        action(managed);
                    }
                }
            }
        }
    }
}
```

**Success Criteria:**

1. **Compilation Test:**
   ```csharp
   [TestMethod]
   public void ReadCopied_Compiles()
   {
       var reader = new DdsReader<TestType>(participant, "TestTopic");
       List<TestType> samples = reader.ReadCopied();
   }
   ```

2. **Functional Test:**
   ```csharp
   [TestMethod]
   public void ReadCopied_ReturnsCorrectData()
   {
       var writer = new DdsWriter<TestType>(participant, "TestTopic");
       var reader = new DdsReader<TestType>(participant, "TestTopic");
       
       var original = new TestType { Id = 42, Name = "Test" };
       writer.Write(original);
       
       Thread.Sleep(100);
       
       var samples = reader.ReadCopied();
       Assert.AreEqual(1, samples.Count);
       Assert.AreEqual(42u, samples[0].Id);
       Assert.AreEqual("Test", samples[0].Name);
   }
   ```

3. **ReadForEach Test:**
   ```csharp
   [TestMethod]
   public void ReadForEach_InvokesCallback()
   {
       // Write samples
       WriteTestSamples(5);
       
       int count = 0;
       reader.ReadForEach(sample =>
       {
           count++;
           Assert.IsNotNull(sample);
       });
       
       Assert.AreEqual(5, count);
   }
   ```

**Effort:** 3 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC017

---

## Phase 5: Edge Cases & Fixes

### FCDC-ZC019: Fix Multi-Dimensional Array Flattening

**Description:**  
Fix bug in `TypeMapper.cs` where multi-dimensional arrays only use first dimension, causing buffer undersize and memory corruption.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 8.1](ZERO-COPY-READ-DESIGN.md#81-multi-dimensional-arrays)

**Files to Modify:**
- `tools/CycloneDDS.IdlImporter/TypeMapper.cs`

**Current Code (Buggy):**
```csharp
if (member.Dimensions != null && member.Dimensions.Count > 0)
{
    arrayLen = member.Dimensions[0]; // BUG: Only first dimension!
}
```

**Fixed Code:**
```csharp
if (member.Dimensions != null && member.Dimensions.Count > 0)
{
    // Flatten multi-dimensional array: [3][4] → 12
    arrayLen = member.Dimensions.Aggregate(1, (product, dimension) => product * dimension);
}
```

**Success Criteria:**

1. **Unit Test - 2D Array:**
   ```csharp
   [TestMethod]
   public void TypeMapper_MultidimensionalArray_Flattens()
   {
       var idl = @"
           module Test {
               struct Matrix {
                   double values[3][4];
               };
           };
       ";
       
       var types = ImportIdl(idl);
       var matrixType = types.First(t => t.Name == "Matrix");
       var valuesField = matrixType.Members.First(m => m.Name == "values");
       
       // Should have [ArrayLength(12)] attribute
       Assert.IsNotNull(valuesField.ArrayLength);
       Assert.AreEqual(12, valuesField.ArrayLength);
   }
   ```

2. **Unit Test - 3D Array:**
   ```csharp
   [TestMethod]
   public void TypeMapper_3DArray_Flattens()
   {
       // Test: double tensor[2][3][4]; → 24
       var idl = @"
           module Test {
               struct Tensor {
                   double values[2][3][4];
               };
           };
       ";
       
       var types = ImportIdl(idl);
       var field = GetField(types, "Tensor", "values");
       
       Assert.AreEqual(24, field.ArrayLength);
   }
   ```

3. **Integration Test:**
   ```csharp
   [TestMethod]
   public void MultidimensionalArray_EndToEnd_NoCorruption()
   {
       // Full cycle: IDL → CodeGen → Compile → Write → Read → Verify
       var idl = @"
           module Test {
               struct Matrix {
                   long id;
                   double matrix[3][4];
               };
           };
       ";
       
       var code = GenerateCode(idl);
       CompileAndLoad(code);
       
       var writer = new DdsWriter<Matrix>(participant, "Matrix");
       var reader = new DdsReader<Matrix>(participant, "Matrix");
       
       var original = new Matrix
       {
           Id = 1,
           Matrix = new double[12] { 1.0, 2.0, ... }
       };
       
       writer.Write(original);
       Thread.Sleep(100);
       
       using (var loan = reader.Read())
       {
           var sample = loan.First();
           var view = sample.AsView();
           
           Assert.AreEqual(1, view.Id);
           var matrix = view.Matrix;
           Assert.AreEqual(12, matrix.Length);
           Assert.AreEqual(1.0, matrix[0]);
       }
   }
   ```

**Effort:** 2 hours  
**Priority:** P0 (Critical - Bug Fix)  
**Dependencies:** None

---

### FCDC-ZC020: Implement Sequence-of-Strings Handling

**Description:**  
Implement marshalling and view access for `sequence<string>`, which requires double indirection (sequence of pointers to strings).

**Reference:** [ZERO-COPY-READ-DESIGN.md § 8.2](ZERO-COPY-READ-DESIGN.md#82-sequence-of-strings-double-indirection)

**Already covered in:** FCDC-ZC011 (view side)

**Additional Work (Write Side):** Ensure `SerializerEmitter` handles this in marshaller.

**Files to Verify:**
- `tools/CycloneDDS.CodeGen/Emitters/SerializerEmitter.cs`

**Marshaller Logic (Reference):**
```csharp
// In MarshalToNative for sequence<string>:
if (source.Messages != null && source.Messages.Count > 0)
{
    int count = source.Messages.Count;
    
    // 1. Allocate array of pointers
    Span<IntPtr> ptrArray = arena.AllocateArray<IntPtr>(count);

    // 2. Loop and allocate each string
    for (int i = 0; i < count; i++)
    {
        ptrArray[i] = arena.CreateString(source.Messages[i]);
    }

    // 3. Set sequence header
    target.messages = new DdsSequenceNative
    {
        Length = (uint)count,
        Maximum = (uint)count,
        Buffer = (IntPtr)Unsafe.AsPointer(ref ptrArray[0]),
        Release = 0
    };
}
```

**Success Criteria:**

1. **Write Test:**
   ```csharp
   [TestMethod]
   public void SequenceOfStrings_Write_Success()
   {
       var writer = new DdsWriter<ChatMessage>(participant, "Chat");
       
       var msg = new ChatMessage
       {
           Id = 1,
           Messages = new List<string> { "Hello", "World", "Test" }
       };
       
       writer.Write(msg); // Should not crash
   }
   ```

2. **Round-Trip Test:**
   ```csharp
   [TestMethod]
   public void SequenceOfStrings_RoundTrip_PreservesData()
   {
       var writer = new DdsWriter<ChatMessage>(participant, "Chat");
       var reader = new DdsReader<ChatMessage>(participant, "Chat");
       
       var original = new ChatMessage
       {
           Messages = new List<string> { "Alpha", "Beta", "Gamma" }
       };
       
       writer.Write(original);
       Thread.Sleep(100);
       
       using (var loan = reader.Read())
       {
           var view = loan.First().AsView();
           
           Assert.AreEqual(3, view.MessagesCount);
           Assert.AreEqual("Alpha", view.GetMessages(0));
           Assert.AreEqual("Beta", view.GetMessages(1));
           Assert.AreEqual("Gamma", view.GetMessages(2));
       }
   }
   ```

3. **Empty Sequence Test:**
   ```csharp
   [TestMethod]
   public void SequenceOfStrings_Empty_HandlesCorrectly()
   {
       var msg = new ChatMessage { Messages = new List<string>() };
       
       writer.Write(msg);
       Thread.Sleep(100);
       
       using (var loan = reader.Read())
       {
           var view = loan.First().AsView();
           Assert.AreEqual(0, view.MessagesCount);
       }
   }
   ```

**Effort:** 4 hours  
**Priority:** P1 (High)  
**Dependencies:** FCDC-ZC011

---

### FCDC-ZC021: Implement Boolean Sequence Safety

**Description:**  
Ensure boolean sequences are handled safely, considering ABI differences between C# `bool` and C `uint8_t`.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 8.3](ZERO-COPY-READ-DESIGN.md#83-boolean-sequences)

**Recommendation:** Use `byte` in view, provide conversion accessor.

**Files to Modify:**
- `tools/CycloneDDS.CodeGen/Emitters/ViewEmitter.cs`

**View Code:**
```csharp
// For: sequence<boolean> flags;

public unsafe ReadOnlySpan<byte> FlagsRaw
{
    get
    {
        return new ReadOnlySpan<byte>(
            (void*)_ptr->flags.Buffer,
            (int)_ptr->flags.Length
        );
    }
}

public bool GetFlag(int index)
{
    if (index < 0 || index >= FlagsRaw.Length)
        throw new ArgumentOutOfRangeException(nameof(index));
    return FlagsRaw[index] != 0;
}
```

**Marshaller Code (Write Side):**
```csharp
// In SerializerEmitter for sequence<boolean>:
if (source.Flags != null && source.Flags.Count > 0)
{
    var boolSpan = CollectionsMarshal.AsSpan(source.Flags);
    var byteSpan = arena.AllocateArray<byte>(boolSpan.Length);

    // Convert bool → byte (ensure 0 or 1)
    for (int i = 0; i < boolSpan.Length; i++)
    {
        byteSpan[i] = boolSpan[i] ? (byte)1 : (byte)0;
    }

    target.flags.Buffer = (IntPtr)Unsafe.AsPointer(ref byteSpan[0]);
    target.flags.Length = (uint)boolSpan.Length;
    target.flags.Maximum = (uint)boolSpan.Length;
    target.flags.Release = 0;
}
```

**Success Criteria:**

1. **Write Test:**
   ```csharp
   [TestMethod]
   public void BooleanSequence_Write_ConvertsCorrectly()
   {
       var data = new TestType
       {
           Flags = new List<bool> { true, false, true }
       };
       
       writer.Write(data); // Should convert to 1, 0, 1
   }
   ```

2. **Read Test:**
   ```csharp
   [TestMethod]
   public unsafe void BooleanSequence_Read_InterpretsCorrectly()
   {
       byte[] data = { 1, 0, 1, 0 };
       fixed (byte* ptr = data)
       {
           var native = new TestType_Native
           {
               flags = new DdsSequenceNative
               {
                   Buffer = (IntPtr)ptr,
                   Length = 4,
                   Maximum = 4,
                   Release = 0
               }
           };
           
           var view = new TestTypeView(&native);
           
           Assert.IsTrue(view.GetFlag(0));
           Assert.IsFalse(view.GetFlag(1));
           Assert.IsTrue(view.GetFlag(2));
           Assert.IsFalse(view.GetFlag(3));
       }
   }
   ```

3. **Round-Trip Test:**
   ```csharp
   [TestMethod]
   public void BooleanSequence_RoundTrip_Preserves()
   {
       var original = new TestType
       {
           Flags = new List<bool> { true, false, true, true, false }
       };
       
       writer.Write(original);
       Thread.Sleep(100);
       
       using (var loan = reader.Read())
       {
           var view = loan.First().AsView();
           for (int i = 0; i < 5; i++)
           {
               Assert.AreEqual(original.Flags[i], view.GetFlag(i));
           }
       }
   }
   ```

**Effort:** 3 hours  
**Priority:** P1 (High)  
**Dependencies:** None

---

### FCDC-ZC022: Handle Keyed Topics & Lifecycle Events

**Description:**  
Ensure views handle samples with `valid_data = 0` (lifecycle events like DISPOSE, UNREGISTER) safely. Document requirement to check `IsValid` before calling `AsView()`.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 8.5](ZERO-COPY-READ-DESIGN.md#85-keyed-topics--dispose-events)

**Files:**
- Documentation in generated view structs
- Runtime validation (optional)

**Implementation:**

1. **Add XML Documentation:**
   ```csharp
   /// <summary>
   /// Casts a DdsSampleRef to a {TypeName}View.
   /// <para>
   /// IMPORTANT: The sample must have valid data. Always check sample.IsValid before calling AsView().
   /// Calling AsView() on an invalid sample (e.g., DISPOSE event) results in undefined behavior.
   /// </para>
   /// </summary>
   /// <exception cref="InvalidOperationException">Thrown if sample.IsValid is false (debug builds only).</exception>
   public static {TypeName}View AsView(this CycloneDDS.Runtime.DdsSampleRef sample)
   {
       #if DEBUG
       if (!sample.IsValid)
           throw new InvalidOperationException("Cannot create view from invalid sample. Check sample.IsValid before calling AsView().");
       #endif
       
       unsafe
       {
           return new {TypeName}View(({TypeName}_Native*)sample.DataPtr);
       }
   }
   ```

2. **Add User Guide Section:** (Part of FCDC-ZC029)

**Success Criteria:**

1. **Documentation Test:**
   ```csharp
   [TestMethod]
   public void AsView_Documentation_ContainsWarning()
   {
       var generatedCode = GenerateCodeForType("TestType");
       Assert.IsTrue(generatedCode.Contains("check sample.IsValid"));
   }
   ```

2. **Debug Mode Test:**
   ```csharp
   [TestMethod]
   public void AsView_InvalidSample_ThrowsInDebug()
   {
       #if DEBUG
       var info = new DdsApi.DdsSampleInfo { ValidData = 0 };
       var sampleRef = new DdsSampleRef(IntPtr.Zero, ref info);
       
       Assert.ThrowsException<InvalidOperationException>(() => sampleRef.AsView());
       #endif
   }
   ```

3. **Integration Test:**
   ```csharp
   [TestMethod]
   public void KeyedTopic_DisposeEvent_HandledCorrectly()
   {
       var writer = new DdsWriter<KeyedType>(participant, "KeyedTopic");
       var reader = new DdsReader<KeyedType>(participant, "KeyedTopic");
       
       var data = new KeyedType { Key = 1, Value = "Test" };
       writer.Write(data);
       writer.DisposeInstance(data);
       
       Thread.Sleep(100);
       
       using (var loan = reader.Read())
       {
           int validCount = 0;
           int disposeCount = 0;
           
           foreach (var sample in loan)
           {
               if (sample.IsValid)
               {
                   var view = sample.AsView();
                   validCount++;
               }
               else
               {
                   // Dispose event
                   disposeCount++;
               }
           }
           
           Assert.AreEqual(1, validCount);
           Assert.IsTrue(disposeCount > 0);
       }
   }
   ```

**Effort:** 3 hours  
**Priority:** P1 (High)  
**Dependencies:** None

---

## Phase 6: Testing & Validation

### FCDC-ZC023: Runtime Unit Tests

**Description:**  
Comprehensive unit tests for `DdsSampleRef`, `DdsLoan`, and `DdsReader` runtime components.

**Reference:** See individual task success criteria from Phase 1

**Test Categories:**

1. **DdsSampleRef Tests** (from FCDC-ZC001)
2. **DdsLoan Lifecycle Tests** (from FCDC-ZC002)
3. **DdsLoan Enumeration Tests** (from FCDC-ZC003)
4. **DdsReader Integration Tests** (from FCDC-ZC004)

**File:** `tests/CycloneDDS.Runtime.Tests/ZeroCopyReadTests.cs`

**Effort:** 8 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** Phase 1 complete

---

### FCDC-ZC024: View Unit Tests

**Description:**  
Unit tests for all generated view types and field accessors.

**Reference:** See individual success criteria from Phase 2

**Test Matrix:**

| Field Type | Test Cases |
|------------|------------|
| Primitives | Access, all types (int8-int64, float, double, bool) |
| Strings | Raw (span), allocating, null, unicode |
| Primitive Sequences | Access, empty, large (1M elements) |
| Struct Sequences | Access, indexing, bounds check |
| String Sequences | Raw/allocating, empty, bounds check |
| Fixed Arrays | 1D, 2D, 3D access |
| Unions | Discriminator, each case, wrong case |
| Optional | Present, absent, null check |

**File:** `tests/CycloneDDS.CodeGen.Tests/ViewTests.cs`

**Effort:** 16 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** Phase 2 complete

---

### FCDC-ZC025: Round-Trip Integration Tests

**Description:**  
End-to-end tests verifying write → DDS → read → view → ToManaged cycle preserves data correctly.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 11.2](ZERO-COPY-READ-DESIGN.md#112-integration-tests)

**Test Cases:**

1. **Simple Primitives Round-Trip**
2. **Strings Round-Trip** (ASCII, Unicode, null)
3. **Sequences Round-Trip** (primitives, structs, strings)
4. **Nested Structs Round-Trip**
5. **Arrays Round-Trip** (fixed, multi-dimensional)
6. **Unions Round-Trip**
7. **Optional Fields Round-Trip**
8. **Large Data Round-Trip** (1MB+ payloads)
9. **Keyed Topics Round-Trip** (with dispose)

**File:** `tests/CycloneDDS.Runtime.Tests/ZeroCopyRoundTripTests.cs`

**Example:**
```csharp
[TestMethod]
public void RoundTrip_ComplexType_PreservesAllFields()
{
    var participant = CreateParticipant();
    var writer = new DdsWriter<ComplexType>(participant, "Test");
    var reader = new DdsReader<ComplexType>(participant, "Test");

    var original = new ComplexType
    {
        Id = 42,
        Name = "Test",
        Values = new List<double> { 1.1, 2.2, 3.3 },
        NestedData = new NestedType { X = 10, Y = 20 }
    };

    writer.Write(original);
    Thread.Sleep(100);

    using (var loan = reader.Read())
    {
        var sample = loan.First();
        Assert.IsTrue(sample.IsValid);

        var view = sample.AsView();
        var managed = view.ToManaged();

        Assert.AreEqual(original.Id, managed.Id);
        Assert.AreEqual(original.Name, managed.Name);
        CollectionAssert.AreEqual(original.Values, managed.Values);
        Assert.AreEqual(original.NestedData.X, managed.NestedData.X);
    }
}
```

**Effort:** 12 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** Phase 2, Phase 4 complete

---

### FCDC-ZC026: Allocation/Performance Tests

**Description:**  
Verify zero-allocation claim and measure performance improvements.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 11.3](ZERO-COPY-READ-DESIGN.md#113-performance-tests)

**Test Cases:**

1. **Zero Allocation Verification**
   ```csharp
   [TestMethod]
   public void ZeroCopyRead_1000Samples_ZeroGen0Collections()
   {
       // Populate with 1000 samples
       PopulateTestData(1000);
       
       long gen0Before = GC.CollectionCount(0);
       long gen1Before = GC.CollectionCount(1);
       long gen2Before = GC.CollectionCount(2);
       
       int processed = 0;
       using (var loan = reader.Read(1000))
       {
           foreach (var sample in loan)
           {
               if (!sample.IsValid) continue;
               var view = sample.AsView();
               _ = view.Id;
               _ = view.Values.Length;
               processed++;
           }
       }
       
       long gen0After = GC.CollectionCount(0);
       long gen1After = GC.CollectionCount(1);
       long gen2After = GC.CollectionCount(2);
       
       Assert.AreEqual(1000, processed);
       Assert.AreEqual(0, gen0After - gen0Before, "Gen0 collections");
       Assert.AreEqual(0, gen1After - gen1Before, "Gen1 collections");
       Assert.AreEqual(0, gen2After - gen2Before, "Gen2 collections");
   }
   ```

2. **Throughput Benchmark**
   ```csharp
   [Benchmark]
   public int ZeroCopyRead_Throughput()
   {
       int count = 0;
       using (var loan = reader.Read())
       {
           foreach (var sample in loan)
           {
               if (sample.IsValid)
               {
                   var view = sample.AsView();
                   count += view.Id;
               }
           }
       }
       return count;
   }

   [Benchmark(Baseline = true)]
   public int AllocatingRead_Throughput()
   {
       var samples = reader.ReadCopied();
       int count = 0;
       foreach (var sample in samples)
       {
           count += sample.Id;
       }
       return count;
   }
   ```

3. **Memory Footprint Test**
   ```csharp
   [TestMethod]
   public void ZeroCopyRead_MemoryFootprint_Minimal()
   {
       GC.Collect();
       GC.WaitForPendingFinalizers();
       GC.Collect();
       
       long memBefore = GC.GetTotalMemory(false);
       
       for (int i = 0; i < 1000; i++)
       {
           using (var loan = reader.Read())
           {
               foreach (var sample in loan)
               {
                   if (sample.IsValid)
                   {
                       var view = sample.AsView();
                       _ = view.Id;
                   }
               }
           }
       }
       
       long memAfter = GC.GetTotalMemory(false);
       long delta = memAfter - memBefore;
       
       // Should be < 1MB for 1000 iterations
       Assert.IsTrue(delta < 1024 * 1024, $"Memory delta: {delta} bytes");
   }
   ```

**File:** `tests/CycloneDDS.Performance.Tests/ZeroCopyPerformanceTests.cs`

**Effort:** 8 hours  
**Priority:** P0 (Critical Path)  
**Dependencies:** Phase 2 complete

---

### FCDC-ZC027: Interop/Compatibility Tests

**Description:**  
Verify interoperability with C++ DDS implementations and compatibility across platforms.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 11.4](ZERO-COPY-READ-DESIGN.md#114-safety-tests)

**Test Cases:**

1. **C++ Publisher → C# Reader**
   - C++ app publishes standard DDS types
   - C# app reads using zero-copy views
   - Verify data matches

2. **C# Writer → C++ Subscriber**
   - C# app writes using native marshalling
   - C++ app subscribes
   - Verify layout matches

3. **Cross-Platform Test**
   - Windows x64
   - Linux x64
   - macOS ARM64 (if applicable)
   - Verify struct alignment consistent

4. **Large Data Stress Test**
   - 10MB+ samples
   - 10,000+ samples/second
   - Run for 10 minutes
   - Verify no crashes, no leaks

**File:** `tests/CycloneDDS.Interop.Tests/ZeroCopyInteropTests.cs`

**Effort:** 12 hours  
**Priority:** P1 (High)  
**Dependencies:** Phase 2, external C++ test app

---

## Phase 7: Documentation

### FCDC-ZC028: API Documentation

**Description:**  
Add comprehensive XML documentation comments to all public APIs.

**Files to Document:**
- `src/CycloneDDS.Runtime/DdsSampleRef.cs`
- `src/CycloneDDS.Runtime/DdsLoan.cs`
- `src/CycloneDDS.Runtime/DdsReader.cs`
- `src/CycloneDDS.Runtime/Extensions/DdsReaderCompatExtensions.cs`
- Generated view structs (template)
- Generated extension methods (template)

**Documentation Standards:**

```csharp
/// <summary>
/// Brief one-line description.
/// </summary>
/// <remarks>
/// Detailed explanation including:
/// - When to use
/// - Performance characteristics
/// - Safety considerations
/// - Usage examples
/// </remarks>
/// <param name="paramName">Parameter description</param>
/// <returns>Return value description</returns>
/// <exception cref="ExceptionType">When thrown</exception>
/// <example>
/// <code>
/// using (var loan = reader.Read())
/// {
///     foreach (var sample in loan)
///     {
///         if (sample.IsValid)
///         {
///             var view = sample.AsView();
///             Console.WriteLine(view.Id);
///         }
///     }
/// }
/// </code>
/// </example>
```

**Effort:** 8 hours  
**Priority:** P1 (High)  
**Dependencies:** All implementation complete

---

### FCDC-ZC029: Migration Guide

**Description:**  
Write comprehensive guide for migrating from allocating API to zero-copy API.

**Reference:** [ZERO-COPY-READ-DESIGN.md § 12](ZERO-COPY-READ-DESIGN.md#12-migration-path)

**File:** `docs/ZERO-COPY-READ-MIGRATION-GUIDE.md`

**Contents:**

1. **Overview**
   - Why migrate
   - Performance benefits
   - Breaking changes summary

2. **Quick Start**
   - Before/after code comparison
   - 5-minute migration checklist

3. **Step-by-Step Guide**
   - Update Read() calls
   - Add using statements
   - Add IsValid checks
   - Replace direct field access with view properties

4. **Common Pitfalls**
   - Forgetting `using`
   - Not checking `IsValid`
   - Trying to store views
   - Using views in async methods

5. **Backwards Compatibility**
   - Using `ReadCopied()`
   - When to use allocating API
   - Performance trade-offs

6. **Advanced Topics**
   - Custom view extensions
   - Span-based processing pipelines
   - Zero-copy serialization chaining

**Effort:** 6 hours  
**Priority:** P1 (High)  
**Dependencies:** Implementation complete

---

### FCDC-ZC030: Performance Best Practices Guide

**Description:**  
Document best practices for achieving maximum performance with zero-copy reads.

**File:** `docs/ZERO-COPY-READ-PERFORMANCE-GUIDE.md`

**Contents:**

1. **Architecture Overview**
   - How zero-copy works
   - Memory layout diagrams
   - Pointer arithmetic explanation

2. **Performance Characteristics**
   - Allocation comparison tables
   - Throughput benchmarks
   - Latency measurements

3. **Best Practices**
   - Always use `using` statements
   - Prefer `ReadOnlySpan` accessors
   - Batch reads (read 100s at once)
   - Avoid string allocation in hot paths
   - Use `ToManaged()` only when necessary

4. **Anti-Patterns**
   - Calling `.ToManaged()` in loop
   - Allocating strings unnecessarily
   - Small batch sizes (read 1-10 samples)
   - Boxing views
   - LINQ on views (not possible anyway)

5. **Profiling Guide**
   - Using BenchmarkDotNet
   - Using dotMemory
   - Identifying allocation hotspots
   - Measuring throughput

6. **Case Studies**
   - High-frequency telemetry (1M samples/sec)
   - Large payload streaming (video frames)
   - Low-latency trading systems

**Effort:** 6 hours  
**Priority:** P1 (High)  
**Dependencies:** Performance tests complete

---

## Summary

**Total Tasks:** 30  
**Total Estimated Effort:** ~170 hours (~21 days)  
**Critical Path:** Phases 1-3 (runtime + code generation)  
**Highest Priority:** P0 tasks (foundation + view generation)

**Recommended Team Size:** 1-2 developers  
**Recommended Duration:** 6-8 weeks (with testing and iteration)

**Next Steps:**
1. Review and approve this task breakdown
2. Create GitHub issues from tasks
3. Begin Phase 1 implementation
4. See [ZERO-COPY-READ-TASK-TRACKER.md](ZERO-COPY-READ-TASK-TRACKER.md) for status tracking
