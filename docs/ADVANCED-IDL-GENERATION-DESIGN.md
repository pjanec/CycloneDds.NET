# Advanced IDL Generation Control Design

**Feature:** Smart IDL file grouping, module mapping, and cross-assembly dependency resolution  
**Priority:** HIGH (Essential for real-world DDS systems)  
**Complexity:** HIGH (Multi-phase refactor of code generator)

---

## 1. Executive Summary

### 1.1 Problem Statement

**Current Limitation:**
The generator creates one IDL file per DDS type, which doesn't match real-world needs:
- No control over physical file organization
- C# namespaces directly map to IDL modules (can't override for legacy interop)
- No cross-assembly dependency resolution
- No automatic `#include` generation

**Real-World Requirements:**
1. **File Grouping:** Multiple types in one IDL file (e.g., `CommonTypes.idl`)
2. **Module Override:** Match legacy IDL module hierarchies regardless of C# namespace
3. **Cross-Assembly:** Assembly B using types from Assembly A should auto-generate `#include "A.idl"`
4. **Build Integration:** IDL files must travel with DLLs for compilation

### 1.2 Solution Overview

Move from **"One Type = One IDL"** to **"Registry & Mapping"** model:

| Aspect | Default Behavior | Override Mechanism |
|--------|------------------|-------------------|
| **File Grouping** | C# filename (e.g., `Geometry.cs` → `Geometry.idl`) | `[DdsIdlFile("Name")]` |
| **Module Hierarchy** | C# namespace (`A.B` → `module A { module B { }}`) | `[DdsIdlModule("A::B")]` |
| **Dependencies** | Auto-detected from field types | Automatic `#include` generation |
| **Cross-Assembly** | Metadata-based lookup via `[DdsIdlMapping]` | Automatic (build system) |

---

## 2. New Attributes

### 2.1 DdsIdlFileAttribute

**Purpose:** Control physical IDL file grouping

```csharp
namespace CycloneDDS.Schema
{
    /// <summary>
    /// Specifies the IDL file name this type should be generated into.
    /// If omitted, defaults to the C# source filename.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false)]
    public sealed class DdsIdlFileAttribute : Attribute
    {
        public string FileName { get; }
        
        /// <param name="fileName">IDL file name WITHOUT extension (e.g., "CommonTypes")</param>
        public DdsIdlFileAttribute(string fileName)
        {
            if (string.IsNullOrWhiteSpace(fileName))
                throw new ArgumentException("File name cannot be empty", nameof(fileName));
            
            if (fileName.Contains(".") || fileName.Contains("/") || fileName.Contains("\\"))
                throw new ArgumentException("File name must not contain extension or path separators", nameof(fileName));
                
            FileName = fileName;
        }
    }
}
```

**Usage:**
```csharp
[DdsStruct]
[DdsIdlFile("MathDefs")]  // Will generate into MathDefs.idl
public partial struct Point3D { ... }
```

### 2.2 DdsIdlModuleAttribute

**Purpose:** Override IDL module hierarchy

```csharp
namespace CycloneDDS.Schema
{
    /// <summary>
    /// Specifies the IDL module hierarchy for this type.
    /// Use "::" as separator (e.g., "LegacySys::Core").
    /// If omitted, defaults to C# namespace converted to modules.
    /// </summary>
    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class, AllowMultiple = false)]
    public sealed class DdsIdlModuleAttribute : Attribute
    {
        public string ModulePath { get; }
        
        /// <param name="modulePath">IDL module path using :: separator (e.g., "Corp::Math::Geo")</param>
        public DdsIdlModuleAttribute(string modulePath)
        {
            if (string.IsNullOrWhiteSpace(modulePath))
                throw new ArgumentException("Module path cannot be empty", nameof(modulePath));
            
            ModulePath = modulePath;
        }
    }
}
```

**Usage:**
```csharp
namespace MyApp.Internal  // C# namespace (doesn't match IDL)

[DdsTopic("State")]
[DdsIdlModule("LegacySys::Core")]  // Force legacy module names
public partial struct SystemState { ... }
```

### 2.3 DdsIdlMappingAttribute (Internal)

**Purpose:** Bake type-to-IDL mapping into compiled assemblies

```csharp
namespace CycloneDDS.Schema
{
    /// <summary>
    /// Internal attribute automatically generated by the code generator.
    /// Records which IDL file a type was generated into.
    /// Used for cross-assembly dependency resolution.
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
    public sealed class DdsIdlMappingAttribute : Attribute
    {
        public string TypeFullName { get; }
        public string IdlFileName { get; }
        public string IdlModule { get; }
        
        public DdsIdlMappingAttribute(string typeName, string idlFile, string idlModule)
        {
            TypeFullName = typeName;
            IdlFileName = idlFile;
            IdlModule = idlModule;
        }
    }
}
```

**Auto-Generated Example:**
```csharp
// Auto-generated in obj/Debug/net8.0/CycloneDDS.IdlMap.g.cs
[assembly: DdsIdlMapping("Corp.Common.Geometry.Point3D", "MathDefs", "Math::Geo")]
[assembly: DdsIdlMapping("Corp.Common.Geometry.Vector3", "MathDefs", "Math::Geo")]
```

---

## 3. Architecture

### 3.1 Three-Phase Generation

**Phase 1: Discovery & Mapping**
- Scan all C# source files
- Extract type info + IDL file/module from attributes or defaults
- Build GlobalTypeRegistry

**Phase 2: Dependency Resolution**
- For each local type, examine field types
- Identify external dependencies (from referenced assemblies)
- Resolve IDL file names via `[DdsIdlMapping]` metadata
- Build dependency graph

**Phase 3: Emission**
- Group types by target IDL file
- Generate `#include` directives for dependencies
- Emit module hierarchies
- Write IDL files to output directory

### 3.2 Global Type Registry

```csharp
public class IdlTypeDefinition
{
    public string CSharpFullName { get; set; }     // "Corp.Common.Point3D"
    public string TargetIdlFile { get; set; }      // "MathDefs" (no extension)
    public string TargetModule { get; set; }       // "Math::Geo"
    public TypeInfo TypeInfo { get; set; }         // Full type metadata
    public bool IsExternal { get; set; }           // From referenced assembly?
    public string SourceFile { get; set; }         // C# filename for defaults
}

public class GlobalTypeRegistry
{
    private Dictionary<string, IdlTypeDefinition> _types = new();
    
    public void RegisterLocal(TypeInfo type, string sourceFileName)
    {
        string idlFile = GetIdlFileName(type, sourceFileName);
        string idlModule = GetIdlModule(type);
        
        _types[type.FullName] = new IdlTypeDefinition
        {
            CSharpFullName = type.FullName,
            TargetIdlFile = idlFile,
            TargetModule = idlModule,
            TypeInfo = type,
            IsExternal = false,
            SourceFile = sourceFileName
        };
    }
    
    public void RegisterExternal(string fullName, string idlFile, string idlModule)
    {
        _types[fullName] = new IdlTypeDefinition
        {
            CSharpFullName = fullName,
            TargetIdlFile = idlFile,
            TargetModule = idlModule,
            IsExternal = true
        };
    }
    
    public bool TryGetDefinition(string fullName, out IdlTypeDefinition def)
        => _types.TryGetValue(fullName, out def);
        
    public IEnumerable<IdlTypeDefinition> LocalTypes 
        => _types.Values.Where(t => !t.IsExternal);
}
```

---

## 4. Detailed Implementation

### 4.1 Attribute Extraction Helpers

```csharp
private string GetIdlFileName(TypeInfo type, string sourceFileName)
{
    // Check for [DdsIdlFile] attribute
    var attr = type.Attributes.FirstOrDefault(a => 
        a.Name == "DdsIdlFile" || a.Name == "DdsIdlFileAttribute");
    
    if (attr != null && attr.Arguments.Count > 0)
    {
        string fileName = attr.Arguments[0] as string;
        ValidateIdlFileName(fileName, type.Name);  // Validation!
        return fileName;
    }
    
    // Default: Use C# source filename without extension
    return Path.GetFileNameWithoutExtension(sourceFileName);
}

private string GetIdlModule(TypeInfo type)
{
    // Check for [DdsIdlModule] attribute
    var attr = type.Attributes.FirstOrDefault(a => 
        a.Name == "DdsIdlModule" || a.Name == "DdsIdlModuleAttribute");
    
    if (attr != null && attr.Arguments.Count > 0)
    {
        string modulePath = attr.Arguments[0] as string;
        ValidateIdlModule(modulePath, type.Name);  // Validation!
        return modulePath;
    }
    
    // Default: Convert C# namespace to IDL modules
    // "Corp.Common.Geo" -> "Corp::Common::Geo"
    return type.Namespace.Replace(".", "::");
}
```

### 4.2 Validation Logic (CRITICAL!)

**Clear error messages for invalid attribute usage:**

```csharp
private void ValidateIdlFileName(string fileName, string typeName)
{
    if (string.IsNullOrWhiteSpace(fileName))
    {
        throw new CodeGenException(
            $"[DdsIdlFile] on type '{typeName}' has empty file name. " +
            "Provide a valid file name without extension (e.g., \"CommonTypes\").");
    }
    
    if (fileName.Contains("."))
    {
        throw new CodeGenException(
            $"[DdsIdlFile(\"{fileName}\")] on type '{typeName}' contains extension. " +
            "Provide file name WITHOUT .idl extension (e.g., \"CommonTypes\" not \"CommonTypes.idl\").");
    }
    
    if (fileName.Any(c => Path.GetInvalidFileNameChars().Contains(c)))
    {
        throw new CodeGenException(
            $"[DdsIdlFile(\"{fileName}\")] on type '{typeName}' contains invalid characters. " +
            "Use only alphanumeric and underscore characters.");
    }
}

private void ValidateIdlModule(string modulePath, string typeName)
{
    if (string.IsNullOrWhiteSpace(modulePath))
    {
        throw new CodeGenException(
            $"[DdsIdlModule] on type '{typeName}' has empty module path. " +
            "Provide a valid path using :: separator (e.g., \"Corp::Math\").");
    }
    
    if (!modulePath.Contains("::"))
    {
        // Single module is OK, but warn if it looks like they used C# style
        if (modulePath.Contains("."))
        {
            throw new CodeGenException(
                $"[DdsIdlModule(\"{modulePath}\")] on type '{typeName}' uses C# namespace syntax. " +
                "Use IDL module syntax with :: separator (e.g., \"Corp::Math\" not \"Corp.Math\").");
        }
    }
    
    // Validate each segment
    var segments = modulePath.Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
    foreach (var segment in segments)
    {
        if (!IsValidIdlIdentifier(segment))
        {
            throw new CodeGenException(
                $"[DdsIdlModule(\"{modulePath}\")] on type '{typeName}' contains invalid segment '{segment}'. " +
                "Each module name must be a valid IDL identifier (alphanumeric, underscore, start with letter).");
        }
    }
}

private bool IsValidIdlIdentifier(string name)
{
    if (string.IsNullOrEmpty(name)) return false;
    if (char.IsDigit(name[0])) return false;  // Can't start with digit
    return name.All(c => char.IsLetterOrDigit(c) || c == '_');
}
```

### 4.3 Cross-Assembly Dependency Resolution

```csharp
private IdlTypeDefinition? ResolveExternalType(Compilation compilation, string fullTypeName)
{
    // Use Roslyn to find the type symbol
    var symbol = compilation.GetTypeByMetadataName(fullTypeName);
    if (symbol == null)
    {
        // Type not found in current compilation or references
        return null;
    }
    
    // Is it defined in the current compilation?
    if (symbol.Locations.Any(loc => loc.IsInSource))
    {
        // Local type, not external
        return null;
    }
    
    // It's from a referenced assembly
    var assembly = symbol.ContainingAssembly;
    
    // Look for [DdsIdlMapping] attributes
    var attributes = assembly.GetAttributes();
    foreach (var attr in attributes)
    {
        if (attr.AttributeClass?.Name != "DdsIdlMappingAttribute")
            continue;
        
        // Extract arguments: TypeFullName, IdlFileName, IdlModule
        if (attr.ConstructorArguments.Length < 3)
            continue;
        
        string mappedType = attr.ConstructorArguments[0].Value as string;
        if (mappedType != fullTypeName)
            continue;
        
        string idlFile = attr.ConstructorArguments[1].Value as string;
        string idlModule = attr.ConstructorArguments[2].Value as string;
        
        return new IdlTypeDefinition
        {
            CSharpFullName = fullTypeName,
            TargetIdlFile = idlFile,
            Target Module = idlModule,
            IsExternal = true
        };
    }
    
    // Type is external but has no IDL mapping
    // This is an ERROR - external DDS types must have mapping
    throw new CodeGenException(
        $"Type '{full TypeName}' from assembly '{assembly.Name}' is used but has no [DdsIdlMapping]. " +
        $"Ensure the assembly was built with the CycloneDDS code generator.");
}
```

### 4.4 IDL Emission with Dependencies

```csharp
public void EmitIdlFiles(GlobalTypeRegistry registry, string outputDir)
{
    // Group local types by target IDL file
    var fileGroups = registry.LocalTypes.GroupBy(t => t.TargetIdlFile);
    
    foreach (var fileGroup in fileGroups)
    {
        string fileName = fileGroup.Key;
        var sb = new StringBuilder();
        
        // Header comment
        sb.AppendLine($"// Auto-generated IDL for {fileName}");
        sb.AppendLine($"// Generated on: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine();
        
        // 1. Generate #include directives
        var dependencies = GetFileDependencies(fileGroup, registry);
        foreach (var depFile in dependencies.OrderBy(f => f))
        {
            sb.AppendLine($"#include \"{depFile}.idl\"");
        }
        
        if (dependencies.Any())
            sb.AppendLine();
        
        // 2. Group by module and emit
        var moduleGroups = fileGroup.GroupBy(t => t.TargetModule);
        foreach (var moduleGroup in moduleGroups.OrderBy(g => g.Key))
        {
            EmitModuleHierarchy(sb, moduleGroup.Key, moduleGroup);
        }
        
        // 3. Write to file
        string outputPath = Path.Combine(outputDir, $"{fileName}.idl");
        File.WriteAllText(outputPath, sb.ToString());
    }
}

private HashSet<string> GetFileDependencies(IEnumerable<IdlTypeDefinition> types, GlobalTypeRegistry registry)
{
    var dependencies = new HashSet<string>();
    
    foreach (var type in types)
    {
        foreach (var field in type.TypeInfo.Fields)
        {
            string fieldType = StripGenerics(field.TypeName);  // Point3D from BoundedSeq<Point3D>
            
            if (registry.TryGetDefinition(fieldType, out var dep))
            {
                // Don't include self-references
                if (dep.TargetIdlFile != type.TargetIdlFile)
                {
                    dependencies.Add(dep.TargetIdlFile);
                }
            }
        }
    }
    
    return dependencies;
}

private void EmitModuleHierarchy(StringBuilder sb, string modulePath, IEnumerable<IdlTypeDefinition> types)
{
    var modules = modulePath.Split(new[] { "::" }, StringSplitOptions.RemoveEmptyEntries);
    
    // Open modules
    int indent = 0;
    foreach (var module in modules)
    {
        sb.AppendLine($"{GetIndent(indent)}module {module} {{");
        indent++;
    }
    
    // Emit types
    foreach (var type in types.OrderBy(t => t.TypeInfo.Name))
    {
        string typeIdl = _idlEmitter.EmitStruct(type.TypeInfo, indent);
        sb.AppendLine(typeIdl);
    }
    
    // Close modules
    for (int i = modules.Length - 1; i >= 0; i--)
    {
        indent--;
        sb.AppendLine($"{GetIndent(indent)}}};  // module {modules[i]}");
    }
    
    sb.AppendLine();
}
```

### 4.5 Assembly Metadata Emission

```csharp
public void EmitAssemblyMappings(GlobalTypeRegistry registry, string outputDir)
{
    var sb = new StringBuilder();
    sb.AppendLine("// Auto-generated IDL mapping metadata");
    sb.AppendLine("using CycloneDDS.Schema;");
    sb.AppendLine();
    
    foreach (var type in registry.LocalTypes.OrderBy(t => t.CSharpFullName))
    {
        sb.AppendLine(
            $"[assembly: DdsIdlMapping(\"{type.CSharpFullName}\", " +
            $"\"{type.TargetIdlFile}\", \"{type.TargetModule}\")]");
    }
    
    string outputPath = Path.Combine(outputDir, "CycloneDDS.IdlMap.g.cs");
    File.WriteAllText(outputPath, sb.ToString());
}
```

---

## 5. Usage Examples

### 5.1 Single Assembly - Default Behavior

**File:** `src/MyApp/Geometry.cs`
```csharp
namespace MyApp.Math
{
    [DdsStruct]
    public partial struct Point3D
    {
        public double X, Y, Z;
    }
    
    [DdsStruct]
    public partial struct Vector3
    {
        public Point3D Start, End;
    }
}
```

**Generated:** `bin/Debug/net8.0/Geometry.idl`
```idl
// Auto-generated IDL for Geometry

module MyApp {
    module Math {
        struct Point3D {
            double X;
            double Y;
            double Z;
        };
        
        struct Vector3 {
            MyApp::Math::Point3D Start;
            MyApp::Math::Point3D End;
        };
    };
};
```

### 5.2 Custom File Grouping

**File:** `src/MyApp/Types.cs`
```csharp
namespace MyApp
{
    [DdsStruct]
    [DdsIdlFile("CommonDefs")]  // Override default "Types.idl"
    public partial struct Header
    {
        public int Sequence;
    }
    
    [DdsStruct]
    [DdsIdlFile("CommonDefs")]  // Same file
    public partial struct Footer
    {
        public long Timestamp;
    }
}
```

**Generated:** `bin/Debug/net8.0/CommonDefs.idl` (both types in one file)
```idl
module MyApp {
    struct Header { long Sequence; };
    struct Footer { int64 Timestamp; };
};
```

### 5.3 Legacy Interoperability

**File:** `src/ModernApp/Bridge.cs`
```csharp
namespace ModernApp.Internal
{
    [DdsTopic("SystemState")]
    [DdsIdlFile("LegacyCore")]           // Match legacy filename
    [DdsIdlModule("LegacySys::Core")]    // Match legacy modules
    public partial struct SystemState
    {
        [DdsKey] public int SystemId;
        public int Status;
    }
}
```

**Generated:** `bin/Debug/net8.0/LegacyCore.idl`
```idl
module LegacySys {
    module Core {
        struct SystemState {
            @key int32 SystemId;
            int32 Status;
        };
    };
};
```

### 5.4 Cross-Assembly Dependencies

**Assembly A:** `Corp.Common.dll`
```csharp
// File: Geometry.cs
namespace Corp.Common.Geometry
{
    [DdsStruct]
    [DdsIdlFile("MathDefs")]
    [DdsIdlModule("Math::Geo")]
    public partial struct Point3D
    {
        public double X, Y, Z;
    }
}
```

**Generated in A:** `bin/Debug/net8.0/MathDefs.idl` + metadata in DLL

**Assembly B:** `Robot.Control.dll` (references A)
```csharp
// File: Navigation.cs
using Corp.Common.Geometry;

namespace Robot.Control
{
    [DdsTopic("Trajectory")]
    public partial struct Trajectory
    {
        [DdsKey] public int RobotId;
        public Point3D StartPoint;               // From Assembly A
        public BoundedSeq<Point3D> Waypoints;    // Collection from A
    }
}
```

**Generated in B:** `bin/Debug/net8.0/Navigation.idl`
```idl
// Auto-generated IDL for Navigation

#include "MathDefs.idl"  // ← Automatically detected!

module Robot {
    module Control {
        struct Trajectory {
            @key int32 RobotId;
            Math::Geo::Point3D StartPoint;
            sequence<Math::Geo::Point3D> Waypoints;
        };
    };
};
```

---

## 6. Build Integration (MSBuild)

### 6.1 IDL File Handling

**Targets in `CycloneDDS.targets`:**

```xml
<Target Name="CopyReferencedIdlFiles" BeforeTargets="CycloneDdsCodeGen">
  <!-- Copy IDL files from referenced assemblies -->
  <ItemGroup>
    <_ReferencedIdlFiles Include="%(ReferenceCopyLocalPaths.RootDir)%(ReferenceCopyLocalPaths.Directory)*.idl" 
                         Condition="Exists('%(ReferenceCopyLocalPaths.RootDir)%(ReferenceCopyLocalPaths.Directory)')" />
  </ItemGroup>
  
  <Copy SourceFiles="@(_ReferencedIdlFiles)" 
        DestinationFolder="$(OutputPath)" 
        SkipUnchangedFiles="true" />
</Target>

<Target Name="IncludeIdlFilesInOutput" AfterTargets="CycloneDdsCodeGen">
  <!-- Include generated IDL files in output -->
  <ItemGroup>
    <None Include="$(OutputPath)*.idl" CopyToOutputDirectory="PreserveNewest" />
  </ItemGroup>
</Target>
```

### 6.2 NuGet Packaging

```xml
<Target Name="PackIdlFiles" BeforeTargets="GenerateNuspec">
  <ItemGroup>
    <Content Include="$(OutputPath)*.idl">
      <Pack>true</Pack>
      <PackagePath>contentFiles/any/any/idl</PackagePath>
      <BuildAction>None</BuildAction>
      <CopyToOutput>true</CopyToOutput>
    </Content>
  </ItemGroup>
</Target>
```

---

## 7. Error Messages (Validation)

**All errors must be clear and actionable:**

| Error Condition | Message |
|----------------|---------|
| [DdsIdlFile] with extension | `[DdsIdlFile("Types.idl")] on 'MyStruct' contains extension. Use "Types" without .idl extension.` |
| [DdsIdlFile] with path | `[DdsIdlFile("../Types")] on 'MyStruct' contains path separators. Use file name only (e.g., "Types").` |
| [Dds IdlModule] with dots | `[DdsIdlModule("A.B.C")] on 'MyStruct' uses C# syntax. Use IDL syntax with :: separator (e.g., "A::B::C").` |
| Invalid module identifier | `[DdsIdlModule("123::Name")] on 'MyStruct' has invalid segment '123'. Module names must start with a letter.` |
| External type no mapping | `Type 'Corp.Common.Point' from 'Corp.Common.dll' is used but has no [DdsIdlMapping]. Rebuild Corp.Common with CycloneDDS generator.` |
| Circular dependency | `Circular IDL dependency detected: A.idl → B.idl → A.idl. Check field types in A and B.` |
| IDL name collision | `IDL name collision: Types 'MyApp.A.Point' and 'MyApp.B.Point' both map to 'Common.idl::MyModule::Point'. Use [DdsIdlModule] to differentiate.` |

### 7.5 Critical Edge Cases

**During implementation, watch for these scenarios:**

#### Edge Case 1: Transitive IDL Copying (The "Diamond" Problem)

**Scenario:**
```
App → LibB → LibA
```
- App depends on LibB
- LibB depends on LibA
- App uses types from LibB
- LibB.idl has `#include "LibA.idl"`

**Requirement:**
`CopyReferencedIdlFiles` in MSBuild must ensure `LibA.idl` gets copied to `App/bin`, even if App doesn't directly use types from LibA in its source code.

**Solution:**
The `ReferenceCopyLocalPaths` mechanism should handle this automatically because:
1. LibB's build output includes `LibA.idl` (copied during LibB's build)
2. When App references LibB, `ReferenceCopyLocalPaths` includes everything from LibB's output
3. Our target copies `*.idl` from reference paths to App's output

**Validation Test:**
```csharp
// Assembly A
[DdsStruct] [DdsIdlFile("A")] public partial struct Base { }

// Assembly B (references A)
[DdsStruct] [DdsIdlFile("B")] public partial struct Middle { public Base field; }

// Assembly C (references B only, not A directly)
[DdsTopic("Top")] public partial struct Top { public Middle field; }
```

**Expected:**
- C's output folder contains: `A.idl`, `B.idl`, `Top.idl`
- B.idl has `#include "A.idl"`
- Top.idl has `#include "B.idl"`

**Test:** `CrossAssembly_Transitive_AllIncluded` (already in test list)

#### Edge Case 2: Stale File Cleanup

**Scenario:**
User changes `[DdsIdlFile("OldName")]` to `[DdsIdlFile("NewName")]`.

**Risk:**
`OldName.idl` remains in `bin/Debug` until Clean/Rebuild. If `idlc` uses wildcards (`*.idl`), it might process the stale file.

**Impact:** Low (not a blocker for v1)

**Mitigation Strategies:**

**Option A: Track Generated Files (Recommended for v1):**
```xml
<Target Name="CleanGeneratedIdl" BeforeTargets="Clean">
  <ItemGroup>
    <_GeneratedIdlFiles Include="$(OutputPath)*.idl" />
  </ItemGroup>
  <Delete Files="@(_GeneratedIdlFiles)" />
</Target>
```

**Option B: Manifest-Based Cleanup (Future Enhancement):**
```csharp
// Generator creates: CycloneDDS.IdlManifest.txt
// Lists all IDL files it created
// Build task reads manifest, deletes files not in current generation
```

**For v1:** Document that users should run Clean before refactoring IDL file names. Add to release notes.

**Known Limitation Note:**
```markdown
### Known Limitation: Stale IDL Files

If you change `[DdsIdlFile]` attributes, run Clean before rebuilding to remove old IDL files.

Example:
1. Original: `[DdsIdlFile("OldName")]` generates `OldName.idl`
2. Changed: `[DdsIdlFile("NewName")]` generates `NewName.idl`
3. Problem: Both files exist in output folder
4. Solution: Run Clean, then Rebuild
```

#### Edge Case 3: IDL Name Collisions

**Scenario:**
Two different C# types (different namespaces) map to the same IDL file + module + type name.

```csharp
namespace MyApp.Data
{
    [DdsStruct]
    [DdsIdlFile("Common")]
    [DdsIdlModule("Shared")]
    public partial struct Point { }
}

namespace MyApp.Geometry
{
    [DdsStruct]
    [DdsIdlFile("Common")]  // Same file!
    [DdsIdlModule("Shared")]  // Same module!
    public partial struct Point { }  // Same name!
}
```

**Result:** Both would generate `module Shared { struct Point { } }` in `Common.idl` → **COLLISION!**

**Solution: Collision Detection in GlobalTypeRegistry**

```csharp
public class GlobalTypeRegistry
{
    private Dictionary<string, IdlTypeDefinition> _typesByCSharpName = new();
    private Dictionary<string, string> _typesByIdlIdentity = new();  // IdlIdentity → CSharpFullName
    
    public void RegisterLocal(TypeInfo type, string sourceFileName)
    {
        string idlFile = GetIdlFileName(type, sourceFileName);
        string idlModule = GetIdlModule(type);
        
        // Create unique IDL identity
        string idlIdentity = $"{idlFile}::{idlModule}::{type.Name}";
        
        // Check for collision
        if (_typesByIdlIdentity.TryGetValue(idlIdentity, out string existingType))
        {
            throw new CodeGenException(
                $"IDL name collision detected:\n" +
                $"  Type 1: '{existingType}'\n" +
                $"  Type 2: '{type.FullName}'\n" +
                $"  Both map to: '{idlFile}.idl' → 'module {idlModule} {{ struct {type.Name} }}'\n" +
                $"\nUse [DdsIdlModule] on one or both types to create distinct module paths.");
        }
        
        _typesByIdlIdentity[idlIdentity] = type.FullName;
        
        // ... rest of registration
    }
}
```

**Error Message Example:**
```
IDL name collision detected:
  Type 1: 'MyApp.Data.Point'
  Type 2: 'MyApp.Geometry.Point'
  Both map to: 'Common.idl' → 'module Shared { struct Point }'

Use [DdsIdlModule] on one or both types to create distinct module paths.
For example:
  [DdsIdlModule("Shared::Data")] on MyApp.Data.Point
  [DdsIdlModule("Shared::Geometry")] on MyApp.Geometry.Point
```

**Test:**
```csharp
// Test: IdlNameCollision_Detected_ClearError
[DdsStruct]
[DdsIdlFile("Common")]
[DdsIdlModule("Shared")]
public partial struct Point1 { }

[DdsStruct]  
[DdsIdlFile("Common")]
[DdsIdlModule("Shared")]  
public partial struct Point1 { }  // Name collision!

// Expected: CodeGenException with clear resolution guidance
```

---

## 8. Testing Requirements

### 8.1 Unit Tests (Minimum 12)

**Attribute Validation:**
1. `ValidateIdlFile_WithExtension_ThrowsError`
2. `ValidateIdlFile_WithPath_ThrowsError`
3. `ValidateIdlModule_WithDots_ThrowsError`
4. `ValidateIdlModule_InvalidIdentifier_ThrowsError`

**Registry:**
5. `Registry_LocalType_StoresCorrectMapping`
6. `Registry_ExternalType_ResolvedViaMetadata`

**Dependency Resolution:**
7. `Dependencies_SameFile_NoInclude`
8. `Dependencies_DifferentFile_AddsInclude`
9. `Dependencies_External_AddsInclude`

**Generation:**
10. `EmitIdl_MultipleModules_NestedCorrectly`
11. `EmitIdl_Dependencies_IncludesFirst`
12. `EmitMetadata_AllTypes_Recorded`

### 8.2 Integration Tests (Minimum 5)

13. `TwoAssemblies_BReferencesA_IncludeGenerated`
    - Assembly A defines Point
    - Assembly B uses Point
    - Success: B's IDL has `#include "A.idl"`

14. `CustomFile_MultipleTypes_SingleIdl`
    - Three types with `[DdsIdlFile("Common")]`
    - Success: One `Common.idl` with all three

15. `CustomModule_LegacyInterop_CorrectHierarchy`
    - C# namespace: `MyApp.Internal`
    - `[DdsIdlModule("Legacy::Sys")]`
    - Success: IDL uses `Legacy::Sys` modules

16. `CrossAssembly_Transitive_AllIncluded`
    - A defines Base, B defines Middle (uses Base), C defines Top (uses Middle)
    - Success: C's IDL includes both A and B

17. `CircularDependency_Detected_ClearError`
    - Type A uses Type B, Type B uses Type A (different files)
    - Success: Clear error message about circular dependency

18. `IdlNameCollision_Detected_ClearError`
    - Two C# types map to same IDL file::module::name
    - Success: Clear error with guidance to use [DdsIdlModule]

---

## 9. Migration Path

**For Existing Code:**
- No attributes = default behavior (filename-based grouping)
- Backwards compatible with current single-file approach
- Can add attributes incrementally as needed

**Recommended Adoption:**
1. Start with defaults
2. Add `[DdsIdlFile]` for grouping common types
3. Add `[DdsIdlModule]` only for legacy interop
4. Cross-assembly works automatically after recompile

---

## 10. Success Criteria

**Functional:**
- ✅ Multiple types can be grouped into one IDL file
- ✅ Module hierarchy can be overridden for legacy compatibility
- ✅ Cross-assembly dependencies auto-generate `#include`
- ✅ Validation errors are clear and actionable
- ✅ IDL files travel with DLLs in build output

**Performance:**
- ✅ Generation time acceptable (< 2s for 100 types)
- ✅ Build incremental (no full regeneration on unrelated changes)

**Usability:**
- ✅ Defaults work for 90% of cases (no attributes needed)
- ✅ Attributes provide full control when needed
- ✅ Error messages guide users to correct fix

---

**Design Status:** Ready for Implementation  
**Complexity:** HIGH (3-phase refactor of code generator)  
**Estimated Effort:** 5-7 days  
**Priority:** HIGH (essential for real-world systems)
