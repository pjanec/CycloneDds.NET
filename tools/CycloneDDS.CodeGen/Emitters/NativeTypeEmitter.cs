using System.Text;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using CycloneDDS.CodeGen.Layout;
using CycloneDDS.CodeGen.Emitters;
using System.Linq;

namespace CycloneDDS.CodeGen.Emitters;

public class NativeTypeEmitter
{
    private readonly StringBuilder _sb = new();
    private readonly StructLayoutCalculator _layoutCalc = new();
    
    private int _paddingIndex = 0;

    /// <summary>
    /// Generate TNative blittable struct from topic type.
    /// </summary>
    public string GenerateNativeStruct(TypeDeclarationSyntax type, string namespaceName)
    {
        _sb.Clear();
        _paddingIndex = 0;
        
        var typeName = type.Identifier.Text;
        var nativeTypeName = $"{typeName}Native";
        
        // File header
        EmitLine("// <auto-generated/>");
        EmitLine($"// Generated native type for {typeName}");
        EmitLine();
        EmitLine("using System;");
        EmitLine("using System.Runtime.InteropServices;");
        EmitLine();
        
        // Namespace
        EmitLine($"namespace {namespaceName};");
        EmitLine();
        
        // Calculate layout
        var layout = _layoutCalc.CalculateLayout(type);
        
        // Struct declaration
        EmitLine($"/// <summary>");
        EmitLine($"/// Native blittable representation of {typeName}.");
        EmitLine($"/// Total size: {layout.TotalSize} bytes, alignment: {layout.MaxAlignment} bytes");
        EmitLine($"/// </summary>");
        EmitLine("[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        EmitLine($"public unsafe struct {nativeTypeName}");
        EmitLine("{");
        
        // Emit fields/properties
        var members = type.Members.Where(m => m is FieldDeclarationSyntax or PropertyDeclarationSyntax);
        
        foreach (var (member, fieldLayout) in members.Zip(layout.Fields))
        {
            EmitMember(member, fieldLayout);
        }
        
        // Emit trailing padding if needed
        if (layout.TrailingPadding > 0)
        {
            EmitLine($"    /// <summary>Trailing padding: {layout.TrailingPadding} bytes</summary>");
            EmitLine($"    private fixed byte _padding{_paddingIndex++}[{layout.TrailingPadding}];");
        }

        EmitLine("}");
        
        return _sb.ToString();
    }
    
    public string GenerateNativeUnion(TypeDeclarationSyntax type, string namespaceName)
    {
        _sb.Clear();
        
        var typeName = type.Identifier.Text;
        var nativeTypeName = $"{typeName}Native";
        
        // File header
        EmitLine("// <auto-generated/>");
        EmitLine($"// Generated native union for {typeName}");
        EmitLine();
        EmitLine("using System;");
        EmitLine("using System.Runtime.InteropServices;");
        EmitLine();
        
        EmitLine($"namespace {namespaceName};");
        EmitLine();
        EmitLine("[StructLayout(LayoutKind.Explicit)]");
        EmitLine($"public unsafe struct {nativeTypeName}");
        EmitLine("{");
        EmitLine("    // Unions not fully supported in BATCH-06 Native Generator yet");
        // Placeholder for now as unions are complex
        EmitLine("}");
        
        return _sb.ToString();
    }

    private void EmitMember(MemberDeclarationSyntax member, FieldLayout layout)
    {
        // Add padding before field if needed
        if (layout.PaddingBefore > 0)
        {
            EmitLine($"    private fixed byte _padding{_paddingIndex++}[{layout.PaddingBefore}];");
        }
        
        string originalType = "";
        string name = layout.FieldName;
        
        if (member is FieldDeclarationSyntax f)
        {
            originalType = f.Declaration.Type.ToString();
        }
        else if (member is PropertyDeclarationSyntax p)
        {
            originalType = p.Type.ToString();
        }
        
        var nativeType = MapToNativeType(originalType);
        
        EmitLine($"    public {nativeType} {name};");
    }
    
    // Simple mapper for native types
    private string MapToNativeType(string csharpType)
    {
        return csharpType switch
        {
            "string" => "IntPtr",
            "bool" => "byte", // Cyclone DDS uses 1 byte bool
            "byte" => "byte",
            "short" => "short",
            "ushort" => "ushort",
            "int" => "int",
            "uint" => "uint",
            "long" => "long",
            "ulong" => "ulong",
            "float" => "float",
            "double" => "double",
            // Arrays? Check if it's array type
            var t when t.Contains("[]") => "IntPtr", // Pointer to first element (simplified)
            // Lists?
            var t when t.StartsWith("List") => "IntPtr",
            _ => csharpType // Other structs map to themselves (assuming generated native struct exists)
        };
    }

    private void EmitLine(string line = "")
    {
        _sb.AppendLine(line);
    }
}
