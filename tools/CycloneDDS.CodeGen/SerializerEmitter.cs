using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using CycloneDDS.Schema;

namespace CycloneDDS.CodeGen
{
    public class SerializerEmitter
    {
        private GlobalTypeRegistry? _registry;

        public string EmitSerializer(TypeInfo type, GlobalTypeRegistry registry, bool generateUsings = true)
        {
            _registry = registry;
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#pragma warning disable CS0162, CS0219, CS8600, CS8601, CS8602, CS8603, CS8604, CS8605, CS8618, CS8625");
            
            // Using directives
            if (generateUsings)
            {
                sb.AppendLine("using System;");
                sb.AppendLine("using CycloneDDS.Core;");
                sb.AppendLine("using CycloneDDS.Runtime;");
                sb.AppendLine("using System.Runtime.InteropServices;"); // Just in case
                sb.AppendLine("using System.Runtime.CompilerServices;");
                sb.AppendLine("using System.Text;");
                sb.AppendLine();
            }
            
            // Namespace
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                sb.AppendLine($"namespace {type.Namespace}");
                sb.AppendLine("{");
            }
            
            // Partial struct (assuming struct as per instructions)
            sb.AppendLine($"    public partial struct {type.Name}");
            sb.AppendLine("    {");
            
            EmitNativeSizer(sb, type);
            EmitMarshaller(sb, type);
            EmitUnmarshalFromNative(sb, type);
            EmitNativeToManaged(sb, type);
            
            if (type.Fields.Any(f => f.HasAttribute("DdsKey")))
            {
                EmitKeyNativeSizer(sb, type);
                EmitKeyMarshaller(sb, type);
            }
            
            // Close class
            sb.AppendLine("    }");

            EmitGhostStruct(sb, type);
            
            // Close namespace
            if (!string.IsNullOrEmpty(type.Namespace))
            {
                sb.AppendLine("}");
            }
            
            return sb.ToString();
        }
        
        private bool IsAppendable(TypeInfo type)
        {
             return type.Extensibility == DdsExtensibilityKind.Appendable || type.Extensibility == DdsExtensibilityKind.Mutable;
        }

        private string GetDiscriminatorCastType(string typeName)
        {
             return typeName;
        }
        
        private bool IsOptional(FieldInfo field)
        {
            return field.TypeName.EndsWith("?") || field.HasAttribute("DdsOptional");
        }

        private bool IsMutable(TypeInfo type)
        {
            return type.Extensibility == DdsExtensibilityKind.Mutable;
        }

        private string GetBaseType(string typeName)
        {
            if (typeName.EndsWith("?"))
                return typeName.Substring(0, typeName.Length - 1);
            return typeName;
        }

        private bool IsReferenceType(string typeName)
        {
            return typeName == "string" || typeName.StartsWith("BoundedSeq");
        }
        
        private bool IsPrimitive(string typeName)
        {
            if (typeName.StartsWith("System.")) typeName = typeName.Substring(7);
            return typeName.ToLower() is 
                "byte" or "uint8" or "sbyte" or "int8" or "bool" or "boolean" or
                "short" or "int16" or "ushort" or "uint16" or
                "int" or "int32" or "uint" or "uint32" or "float" or "single" or
                "long" or "int64" or "ulong" or "uint64" or "double";
        }
        
        private string ExtractGenericType(string typeName)
        {
            int start = typeName.IndexOf('<') + 1;
            int end = typeName.LastIndexOf('>');
            if (start > 0 && end > start)
                return typeName.Substring(start, end - start).Trim();
            return typeName;
        }

        private void EmitMarshaller(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"        public static unsafe void MarshalToNative(in {type.Name} source, IntPtr targetPtr, ref NativeArena arena)");
            sb.AppendLine("        {");
            sb.AppendLine($"            ref var target = ref Unsafe.AsRef<{type.Name}_Native>((void*)targetPtr);");
            sb.AppendLine($"            target = default;");
            sb.AppendLine("            MarshalToNative(source, ref target, ref arena);");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine($"        internal static unsafe void MarshalToNative(in {type.Name} source, ref {type.Name}_Native target, ref NativeArena arena)");
            sb.AppendLine("        {");

            if (type.HasAttribute("DdsUnion"))
            {
               EmitUnionMarshallerBody(sb, type);
            }
            else
            {
                foreach (var field in type.Fields)
                {
                    EmitFieldMarshal(sb, field, type, "target", "source");
                }
            }
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void EmitUnionMarshallerBody(StringBuilder sb, TypeInfo type)
        {
             var discriminator = type.Fields.FirstOrDefault(f => f.HasAttribute("DdsDiscriminator"));
             if (discriminator == null) return;
             
             if (discriminator.TypeName == "bool" || discriminator.TypeName == "Boolean" || discriminator.TypeName == "System.Boolean")
             {
                 sb.AppendLine($"            target._d = source.{ToPascalCase(discriminator.Name)} ? (byte)1 : (byte)0;");
             }
             else
             {
                 string castType = GetDiscriminatorCastType(discriminator.TypeName);
                 string castExpr = castType == "bool" ? "" : $"({castType})";
                 sb.AppendLine($"            target._d = {castExpr}source.{ToPascalCase(discriminator.Name)};");
             }
             
             sb.AppendLine($"            switch (source.{ToPascalCase(discriminator.Name)})");
             sb.AppendLine("            {");

             foreach (var field in type.Fields)
             {
                var caseAttr = field.GetAttribute("DdsCase");
                if (caseAttr != null)
                {
                    foreach (var val in caseAttr.CaseValues)
                    {
                        string caseLabel = val!.ToString()!;
                        if (val is bool b) caseLabel = b ? "true" : "false";
                         else if (!IsPrimitive(discriminator.TypeName) && discriminator.TypeName != "string")
                         {
                              caseLabel = $"({discriminator.TypeName}){val}"; 
                         }
                        sb.AppendLine($"                case {caseLabel}:");
                    }
                    sb.AppendLine("                {");
                    EmitFieldMarshal(sb, field, type, "target._u", "source");
                    sb.AppendLine("                    break;");
                    sb.AppendLine("                }");
                }
             }
             
             var defaultField = type.Fields.FirstOrDefault(f => f.HasAttribute("DdsDefaultCase"));
             if (defaultField != null)
             {
                 sb.AppendLine("                default:");
                 sb.AppendLine("                {");
                 EmitFieldMarshal(sb, defaultField, type, "target._u", "source");
                 sb.AppendLine("                    break;");
                 sb.AppendLine("                }");
             }
             else
             {
                  sb.AppendLine("                default: break;");
             }

             sb.AppendLine("            }");
        }

        private void EmitFieldMarshal(StringBuilder sb, FieldInfo field, TypeInfo parentType, string targetPrefix, string sourcePrefix)
        {
             string sourceAccess = $"{sourcePrefix}.{ToPascalCase(field.Name)}";
             string targetAccess = $"{targetPrefix}.{field.Name}";

             if (IsOptional(field))
             {
                 string baseType = GetBaseType(field.TypeName);
                 string check = field.TypeName == "string?" ? $"{sourceAccess} != null" : $"{sourceAccess}.HasValue";
                 string valAccess = (field.TypeName == "string?" || IsReferenceType(baseType)) ? sourceAccess : $"{sourceAccess}.Value";
                 
                 sb.AppendLine($"            if ({check})");
                 sb.AppendLine("            {");
                 
                 if (IsPrimitive(baseType) || baseType == "bool")
                 {
                      bool isBool = baseType == "bool" || baseType == "Boolean" || baseType == "System.Boolean";
                      string nativeType = isBool ? "byte" : baseType;
                      string valExpr = isBool ? $"({valAccess} ? (byte)1 : (byte)0)" : valAccess;
                      
                      sb.AppendLine($"                var __span = arena.AllocateArray<{nativeType}>(1);");
                      sb.AppendLine($"                __span[0] = {valExpr};");
                      sb.AppendLine($"                {targetAccess} = (IntPtr)Unsafe.AsPointer(ref __span[0]);");
                 }
                 else if (baseType == "string" || baseType == "System.String")
                 {
                     sb.AppendLine($"                {targetAccess} = arena.CreateString({valAccess});");
                 }
                 else if (baseType.EndsWith("[]") || baseType.StartsWith("List") || baseType.StartsWith("BoundedSeq")) 
                 {
                      // Optional Sequence fall through
                 }
                 else
                 {
                     string nativeType = $"{baseType}_Native";
                     sb.AppendLine($"                var __span = arena.AllocateArray<{nativeType}>(1);");
                     sb.AppendLine($"                var __valTemp = {valAccess};");
                     sb.AppendLine($"                {baseType}.MarshalToNative(in __valTemp, ref __span[0], ref arena);");
                     sb.AppendLine($"                {targetAccess} = (IntPtr)Unsafe.AsPointer(ref __span[0]);");
                 }
                 
                 sb.AppendLine("            }");
                 sb.AppendLine("            else");
                 sb.AppendLine("            {");
                 sb.AppendLine($"                {targetAccess} = IntPtr.Zero;");
                 sb.AppendLine("            }");
                 
                 return;
             }
             

             // Resolve TypeInfo if missing
             TypeInfo? fieldType = field.Type;
             if (fieldType == null && _registry != null && _registry.TryGetDefinition(field.TypeName, out var def))
             {
                 fieldType = def.TypeInfo;
             }

             if (field.TypeName == "string" || field.TypeName == "System.String")
             {
                 int? maxLen = GetMaxLength(field);
                 if (maxLen.HasValue)
                 {
                     sb.AppendLine($"            if (!string.IsNullOrEmpty({sourceAccess}))");
                     sb.AppendLine("            {");
                     sb.AppendLine($"                var __bytes = System.Text.Encoding.UTF8.GetBytes({sourceAccess});");
                     sb.AppendLine($"                if (__bytes.Length > {maxLen.Value}) throw new InvalidOperationException(\"String exceeds MaxLength {maxLen.Value}\");");
                     sb.AppendLine($"                fixed (byte* __dest = {targetAccess})"); 
                     sb.AppendLine($"                {{");
                     sb.AppendLine($"                    System.Runtime.InteropServices.Marshal.Copy(__bytes, 0, (IntPtr)__dest, __bytes.Length);");
                     sb.AppendLine($"                    __dest[__bytes.Length] = 0;");
                     sb.AppendLine($"                }}");
                     sb.AppendLine("            }");
                     sb.AppendLine("            else");
                     sb.AppendLine("            {");
                     sb.AppendLine($"                fixed (byte* __dest = {targetAccess}) __dest[0] = 0;");
                     sb.AppendLine("            }");
                 }
                 else
                 {
                     sb.AppendLine($"            {targetAccess} = arena.CreateString({sourceAccess});");
                 }
             }
             else if (field.TypeName == "bool" || field.TypeName == "Boolean" || field.TypeName == "System.Boolean")
             {
                 sb.AppendLine($"            {targetAccess} = {sourceAccess} ? (byte)1 : (byte)0;");
             }
             else if (fieldType != null && fieldType.IsEnum)
             {
                 sb.AppendLine($"            {targetAccess} = (int){sourceAccess};");
             }
             else if (field.TypeName.StartsWith("List<") || field.TypeName.StartsWith("System.Collections.Generic.List<") || field.TypeName.EndsWith("[]") || field.TypeName.StartsWith("BoundedSeq"))
             {
                 EmitSequenceMarshal(sb, field, sourceAccess, targetAccess);
             }
             else if (fieldType != null && (fieldType.IsStruct || fieldType.IsUnion || fieldType.IsTopic) && !fieldType.IsEnum)
             {
                 string typeName = field.TypeName;
                 sb.AppendLine($"            var __{field.Name}_temp = {sourceAccess};");
                 sb.AppendLine($"            {typeName}.MarshalToNative(in __{field.Name}_temp, ref {targetAccess}, ref arena);");
             }
             else 
             {
                 sb.AppendLine($"            {targetAccess} = {sourceAccess};");
             }
        }

        private void EmitSequenceMarshal(StringBuilder sb, FieldInfo field, string sourceAccess, string targetAccess)
        {
             string elementType = ExtractGenericType(field.TypeName);
             if (field.TypeName.EndsWith("[]")) elementType = field.TypeName.Substring(0, field.TypeName.Length - 2);
             string countProp = field.TypeName.EndsWith("[]") ? "Length" : "Count";
             
             string nullCheck = field.TypeName.StartsWith("BoundedSeq") ? "" : $"{sourceAccess} != null && ";

             if (IsPrimitive(elementType))
             {
                  string pType = elementType == "bool" ? "byte" : elementType;
                  
                  if (elementType == "bool")
                  {
                       sb.AppendLine($"            if ({nullCheck}{sourceAccess}.{countProp} > 0)");
                       sb.AppendLine($"            {{");
                       sb.AppendLine($"                var __span = arena.AllocateArray<byte>({sourceAccess}.{countProp});");
                       sb.AppendLine($"                for(int i=0; i<{sourceAccess}.{countProp}; ++i) __span[i] = {sourceAccess}[i] ? (byte)1 : (byte)0;");
                       sb.AppendLine($"                {targetAccess} = new DdsSequenceNative {{ Maximum = (uint){sourceAccess}.{countProp}, Length = (uint){sourceAccess}.{countProp}, Buffer = (IntPtr)Unsafe.AsPointer(ref __span[0]) }};");
                       sb.AppendLine($"            }}");
                       sb.AppendLine($"            else");
                       sb.AppendLine($"            {{");
                       sb.AppendLine($"                {targetAccess} = new DdsSequenceNative();");
                       sb.AppendLine($"            }}");
                  }
                  else
                  {
                       string spanExpr;
                       if (field.TypeName.EndsWith("[]")) spanExpr = $"{sourceAccess}.AsSpan()";
                       else if (field.TypeName.StartsWith("BoundedSeq")) spanExpr = $"{sourceAccess}.AsSpan()";
                       else spanExpr = $"System.Runtime.InteropServices.CollectionsMarshal.AsSpan({sourceAccess})";

                       sb.AppendLine($"            if ({nullCheck}{sourceAccess}.{countProp} > 0)");
                       sb.AppendLine($"            {{");
                       sb.AppendLine($"                {targetAccess} = arena.CreateSequence<{pType}>({spanExpr});");
                       sb.AppendLine($"            }}");
                       sb.AppendLine($"            else");
                       sb.AppendLine($"            {{");
                       sb.AppendLine($"                {targetAccess} = new DdsSequenceNative();");
                       sb.AppendLine($"            }}");
                  }
             }
             else if (elementType == "string" || elementType == "System.String")
             {
                  sb.AppendLine($"            if ({nullCheck}{sourceAccess}.{countProp} > 0)");
                  sb.AppendLine($"            {{");
                  sb.AppendLine($"                var __span = arena.AllocateArray<IntPtr>({sourceAccess}.{countProp});");
                  sb.AppendLine($"                for (int i = 0; i < {sourceAccess}.{countProp}; i++)");
                  sb.AppendLine($"                {{");
                  sb.AppendLine($"                    __span[i] = arena.CreateString({sourceAccess}[i]);");
                  sb.AppendLine($"                }}");
                  sb.AppendLine($"                {targetAccess} = new DdsSequenceNative {{ Maximum = (uint){sourceAccess}.{countProp}, Length = (uint){sourceAccess}.{countProp}, Buffer = (IntPtr)Unsafe.AsPointer(ref __span[0]) }};");
                  sb.AppendLine($"            }}");
                  sb.AppendLine($"            else");
                  sb.AppendLine($"            {{");
                  sb.AppendLine($"                {targetAccess} = new DdsSequenceNative();");
                  sb.AppendLine($"            }}");
             }
             else
             {
                  string nativeEl = $"{elementType}_Native";

                  sb.AppendLine($"            if ({nullCheck}{sourceAccess}.{countProp} > 0)");
                  sb.AppendLine($"            {{");
                  // sb.AppendLine($"                System.Console.WriteLine(\"Marshalling Sequence {field.Name} Count: \" + {sourceAccess}.{countProp});");
                  sb.AppendLine($"                var __span = arena.AllocateArray<{nativeEl}>({sourceAccess}.{countProp});");
                  sb.AppendLine($"                for (int i = 0; i < {sourceAccess}.{countProp}; i++)");
                  sb.AppendLine($"                {{");
                  sb.AppendLine($"                    var __item = {sourceAccess}[i];");
                  sb.AppendLine($"                    {elementType}.MarshalToNative(in __item, ref __span[i], ref arena);");
                  sb.AppendLine($"                }}");
                  sb.AppendLine($"                {targetAccess} = new DdsSequenceNative {{ Maximum = (uint){sourceAccess}.{countProp}, Length = (uint){sourceAccess}.{countProp}, Buffer = (IntPtr)Unsafe.AsPointer(ref __span[0]) }};");
                  sb.AppendLine($"            }}");
                  sb.AppendLine($"            else");
                  sb.AppendLine($"            {{");
                  sb.AppendLine($"                {targetAccess} = new DdsSequenceNative();");
                  sb.AppendLine($"            }}");
             }
        }
        
        private void EmitKeyMarshaller(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"        public static unsafe void MarshalKeyToNative(in {type.Name} source, IntPtr targetPtr, ref NativeArena arena)");
            sb.AppendLine("        {");
            sb.AppendLine($"            ref var target = ref Unsafe.AsRef<{type.Name}_Native>((void*)targetPtr);");
            sb.AppendLine("            MarshalKeyToNative(source, ref target, ref arena);");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine($"        internal static unsafe void MarshalKeyToNative(in {type.Name} source, ref {type.Name}_Native target, ref NativeArena arena)");
            sb.AppendLine("        {");
            if (type.HasAttribute("DdsUnion"))
            {
               EmitUnionMarshallerBody(sb, type);
            }
            else
            {
                foreach (var field in type.Fields)
                {
                    if (field.HasAttribute("DdsKey"))
                    {
                        EmitFieldMarshal(sb, field, type, "target", "source");
                    }
                }
            }
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void EmitNativeToManaged(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"        public static unsafe {type.Name} FromNative(IntPtr nativePtr)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (nativePtr == IntPtr.Zero) return default;");
            
            if (type.HasAttribute("DdsTopic"))
            {
                foreach(var field in type.Fields)
                {
                     sb.AppendLine($"            System.Console.WriteLine(\"Offset {field.Name}: \" + System.Runtime.InteropServices.Marshal.OffsetOf(typeof({type.Name}_Native), \"{field.Name}\"));");
                }
                sb.AppendLine($"            System.Console.WriteLine(\"Size {type.Name}_Native: \" + System.Runtime.CompilerServices.Unsafe.SizeOf<{type.Name}_Native>());");
            }
            sb.AppendLine($"            var native = *({type.Name}_Native*)nativePtr;");
            sb.AppendLine($"            var managed = new {type.Name}();");
            sb.AppendLine($"            MarshalFromNative(ref managed, in native);");
            sb.AppendLine("            return managed;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void EmitUnmarshalFromNative(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"        internal static unsafe void MarshalFromNative(IntPtr nativeData, out {type.Name} managedData)");
            sb.AppendLine("        {");
            sb.AppendLine($"            managedData = default;");
            sb.AppendLine($"            MarshalFromNative(ref managedData, in System.Runtime.CompilerServices.Unsafe.AsRef<{type.Name}_Native>((void*)nativeData));");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine($"        internal static unsafe void MarshalFromNative(ref {type.Name} target, in {type.Name}_Native source)");
            sb.AppendLine("        {");
            sb.AppendLine($"            System.Console.WriteLine(\"MarshalFromNative {type.Name}\");");

            if (type.HasAttribute("DdsUnion"))
            {
               EmitUnionUnmarshalBody(sb, type);
            }
            else
            {
                foreach (var field in type.Fields)
                {
                     EmitFieldUnmarshal(sb, field, type, "target", "source");
                }
            }
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void EmitUnionUnmarshalBody(StringBuilder sb, TypeInfo type)
        {
             var discriminator = type.Fields.FirstOrDefault(f => f.HasAttribute("DdsDiscriminator"));
             if (discriminator == null) return;
             
             if (discriminator.TypeName == "bool" || discriminator.TypeName == "Boolean" || discriminator.TypeName == "System.Boolean")
             {
                 sb.AppendLine($"            target.{ToPascalCase(discriminator.Name)} = source._d != 0;");
             }
             else
             {
                 string castType = GetDiscriminatorCastType(discriminator.TypeName);
                 string castExpr = castType == "bool" ? "" : $"({castType})";
                 sb.AppendLine($"            target.{ToPascalCase(discriminator.Name)} = {castExpr}source._d;");
             }
             
             sb.AppendLine($"            switch (target.{ToPascalCase(discriminator.Name)})");
             sb.AppendLine("            {");

             foreach (var field in type.Fields)
             {
                var caseAttr = field.GetAttribute("DdsCase");
                if (caseAttr != null)
                {
                    foreach (var val in caseAttr.CaseValues)
                    {
                        string caseLabel = val!.ToString()!;
                        if (val is bool b) caseLabel = b ? "true" : "false";
                         else if (!IsPrimitive(discriminator.TypeName) && discriminator.TypeName != "string")
                         {
                              caseLabel = $"({discriminator.TypeName}){val}"; 
                         }
                        sb.AppendLine($"                case {caseLabel}:");
                    }
                    sb.AppendLine("                {");
                    EmitFieldUnmarshal(sb, field, type, "target", "source._u");
                    sb.AppendLine("                    break;");
                    sb.AppendLine("                }");
                }
             }
             
             var defaultField = type.Fields.FirstOrDefault(f => f.HasAttribute("DdsDefaultCase"));
             if (defaultField != null)
             {
                 sb.AppendLine("                default:");
                 sb.AppendLine("                {");
                 EmitFieldUnmarshal(sb, defaultField, type, "target", "source._u");
                 sb.AppendLine("                    break;");
                 sb.AppendLine("                }");
             }
             else
             {
                  sb.AppendLine("                default: break;");
             }

             sb.AppendLine("            }");
        }

        private void EmitFieldUnmarshal(StringBuilder sb, FieldInfo field, TypeInfo parentType, string targetPrefix, string sourcePrefix)
        {
             string sourceAccess = $"{sourcePrefix}.{field.Name}";
             string targetAccess = $"{targetPrefix}.{ToPascalCase(field.Name)}";

             // Resolve TypeInfo if missing
             TypeInfo? fieldType = field.Type;
             if (fieldType == null && _registry != null && _registry.TryGetDefinition(field.TypeName, out var def))
             {
                 fieldType = def.TypeInfo;
             }

             if (IsOptional(field))
             {
                 string baseType = GetBaseType(field.TypeName);
                 
                 sb.AppendLine($"            if ({sourceAccess} != IntPtr.Zero)");
                 sb.AppendLine("            {");
                 
                 if (IsPrimitive(baseType) || baseType == "bool")
                 {
                      string nativeType = (baseType == "bool" || baseType == "Boolean" || baseType == "System.Boolean") ? "byte" : baseType;
                      
                      sb.AppendLine($"                var __ptr = ({nativeType}*){sourceAccess};");
                      if (baseType == "bool" || baseType == "Boolean" || baseType == "System.Boolean")
                           sb.AppendLine($"                {targetAccess} = *__ptr != 0;");
                      else
                           sb.AppendLine($"                {targetAccess} = *__ptr;");
                 }
                 else if (baseType == "string" || baseType == "System.String")
                 {
                     sb.AppendLine($"                {targetAccess} = DdsTextEncoding.FromNativeUtf8({sourceAccess});");
                 }
                 else if (baseType.EndsWith("[]") || baseType.StartsWith("List<") || baseType.StartsWith("System.Collections.Generic.List<") || baseType.StartsWith("BoundedSeq")) 
                 {
                      sb.AppendLine($"                var __seqPtr = (DdsSequenceNative*){sourceAccess};");
                      EmitSequenceUnmarshal(sb, field, "(*__seqPtr)", targetAccess);
                 }
                 else
                 {
                      sb.AppendLine($"                var __native = *({baseType}_Native*){sourceAccess};");
                      sb.AppendLine($"                {baseType} __managed = new {baseType}();");
                      sb.AppendLine($"                {baseType}.MarshalFromNative(ref __managed, in __native);");
                      sb.AppendLine($"                {targetAccess} = __managed;");
                 }
                 
                 sb.AppendLine("            }");
                 sb.AppendLine("            else");
                 sb.AppendLine("            {");
                 sb.AppendLine($"                {targetAccess} = default;");
                 sb.AppendLine("            }");
                 return;
             }
             
             if (field.TypeName == "string" || field.TypeName == "System.String")
             {
                 int? maxLen = GetMaxLength(field);
                 if (maxLen.HasValue)
                 {
                     sb.AppendLine($"            fixed (byte* __ptr = {sourceAccess})");
                     sb.AppendLine($"            {{");
                     sb.AppendLine($"                {targetAccess} = DdsTextEncoding.FromNativeUtf8((IntPtr)__ptr);");
                     sb.AppendLine($"            }}");
                 }
                 else
                 {
                     sb.AppendLine($"            {targetAccess} = DdsTextEncoding.FromNativeUtf8({sourceAccess});");
                 }
             }
             else if (field.TypeName == "bool" || field.TypeName == "Boolean" || field.TypeName == "System.Boolean")
             {
                 sb.AppendLine($"            {targetAccess} = {sourceAccess} != 0;");
             }
             else if (fieldType != null && fieldType.IsEnum)
             {
                 sb.AppendLine($"            {targetAccess} = ({field.TypeName}){sourceAccess};");
             }
             else if (field.TypeName.StartsWith("List<") || field.TypeName.StartsWith("System.Collections.Generic.List<") || field.TypeName.EndsWith("[]") || field.TypeName.StartsWith("BoundedSeq"))
             {
                 EmitSequenceUnmarshal(sb, field, sourceAccess, targetAccess);
             }
             else if (fieldType != null && (fieldType.IsStruct || fieldType.IsUnion || fieldType.IsTopic) && !fieldType.IsEnum)
             {
                 string typeName = field.TypeName;
                 sb.AppendLine($"            var __{field.Name}_target = new {typeName}();");
                 sb.AppendLine($"            {typeName}.MarshalFromNative(ref __{field.Name}_target, in {sourceAccess});");
                 sb.AppendLine($"            {targetAccess} = __{field.Name}_target;");
             }
             else 
             {
                 sb.AppendLine($"            {targetAccess} = {sourceAccess};");
             }
        }
        
        private void EmitSequenceUnmarshal(StringBuilder sb, FieldInfo field, string sourceAccess, string targetAccess)
        {
             string elementType = ExtractGenericType(field.TypeName);
             if (field.TypeName.EndsWith("[]")) elementType = field.TypeName.Substring(0, field.TypeName.Length - 2);
             
             sb.AppendLine($"            {{");
             sb.AppendLine($"                var __seq = {sourceAccess};");
             sb.AppendLine($"                System.Console.WriteLine($\"Sequence {field.Name} Length: {{__seq.Length}} Max: {{__seq.Maximum}} Buffer: {{__seq.Buffer}}\");");

             if (field.TypeName.StartsWith("List<") || field.TypeName.StartsWith("System.Collections.Generic.List<"))
             {
                 sb.AppendLine($"                {targetAccess} = new System.Collections.Generic.List<{elementType}>((int)__seq.Length);");
                 EmitSequenceUnmarshalLoop(sb, elementType, targetAccess, "__seq", true);
             }
             else if (field.TypeName.EndsWith("[]"))
             {
                 sb.AppendLine($"                {targetAccess} = new {elementType}[(int)__seq.Length];");
                  EmitSequenceUnmarshalLoop(sb, elementType, targetAccess, "__seq", false);
             }
             else if (field.TypeName.StartsWith("BoundedSeq"))
             {
                  sb.AppendLine($"                {targetAccess} = new {field.TypeName}((int)__seq.Maximum);");
                  EmitSequenceUnmarshalLoop(sb, elementType, targetAccess, "__seq", true, true);
             }

             sb.AppendLine($"            }}");
        }

        private void EmitSequenceUnmarshalLoop(StringBuilder sb, string elementType, string targetAccess, string seqVar, bool isList, bool isBoundedSeq = false)
        {
             sb.AppendLine($"                System.Console.WriteLine(\"Unmarshal Seq {elementType} Len: \" + {seqVar}.Length + \" Max: \" + {seqVar}.Maximum + \" Buf: \" + {seqVar}.Buffer);");

             if (IsPrimitive(elementType))
             {
                  string pType = elementType == "bool" ? "byte" : elementType;
                  
                  sb.AppendLine($"                var __span = new Span<{pType}>((void*){seqVar}.Buffer, (int){seqVar}.Length);");
                  sb.AppendLine($"                for (int i = 0; i < (int){seqVar}.Length; i++)");
                  sb.AppendLine("                {");
                  string valExpr = elementType == "bool" ? "(__span[i] != 0)" : $"__span[i]";
                  
                  if (isList || isBoundedSeq)
                        sb.AppendLine($"                    {targetAccess}.Add({valExpr});");
                  else
                        sb.AppendLine($"                    {targetAccess}[i] = {valExpr};");
                        
                  sb.AppendLine("                }");
             }
             else if (elementType == "string" || elementType == "System.String")
             {
                  sb.AppendLine($"                var __span = new Span<IntPtr>((void*){seqVar}.Buffer, (int){seqVar}.Length);");
                  sb.AppendLine($"                for (int i = 0; i < (int){seqVar}.Length; i++)");
                  sb.AppendLine("                {");
                  // Use FromNativeUtf8 instead of GetString
                  sb.AppendLine($"                    var __str = DdsTextEncoding.FromNativeUtf8(__span[i]);");
                  if (isList || isBoundedSeq)
                        sb.AppendLine($"                    {targetAccess}.Add(__str);");
                  else
                        sb.AppendLine($"                    {targetAccess}[i] = __str;");
                  sb.AppendLine("                }");
             }
             else
             {
                  string nativeEl = $"{elementType}_Native";
                  sb.AppendLine($"                var __span = new Span<{nativeEl}>((void*){seqVar}.Buffer, (int){seqVar}.Length);");
                  sb.AppendLine($"                for (int i = 0; i < (int){seqVar}.Length; i++)");
                  sb.AppendLine("                {");
                  sb.AppendLine($"                    {elementType} __item = new {elementType}();");
                  sb.AppendLine($"                    {elementType}.MarshalFromNative(ref __item, in __span[i]);");
                  if (isList || isBoundedSeq)
                        sb.AppendLine($"                    {targetAccess}.Add(__item);");
                  else
                        sb.AppendLine($"                    {targetAccess}[i] = __item;");
                  sb.AppendLine("                }");
             }
        }

        private void EmitKeyNativeSizer(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"        public static int GetKeyNativeSize(in {type.Name} source)");
            sb.AppendLine("        {");
            sb.AppendLine($"            int currentOffset = Unsafe.SizeOf<{type.Name}_Native>();"); 
            
            bool hasDynamic = false;
            foreach (var field in type.Fields)
            {
                if (field.HasAttribute("DdsKey") && IsDynamic(field)) hasDynamic = true;
            }
            
            if (hasDynamic)
            {
                 foreach(var field in type.Fields)
                 {
                      if (field.HasAttribute("DdsKey") && IsDynamic(field))
                      {
                          EmitFieldDynamicSize(sb, field);
                      }
                 }
            }

            sb.AppendLine("            return currentOffset;");
            sb.AppendLine("        }");
            
            sb.AppendLine($"        public static int GetKeyNativeHeadSize()");
            sb.AppendLine("        {");
            sb.AppendLine($"            return Unsafe.SizeOf<{type.Name}_Native>();");
            sb.AppendLine("        }");
            sb.AppendLine();
        }

        private void EmitNativeSizer(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine($"        public static int GetNativeSize(in {type.Name} source)");
            sb.AppendLine("        {");
            sb.AppendLine($"            int size = Unsafe.SizeOf<{type.Name}_Native>();");
            
            bool hasDynamic = false;
            foreach(var field in type.Fields) 
            {
                 if (IsDynamic(field)) hasDynamic = true;
            }

            if (hasDynamic)
            {
                 sb.AppendLine("            size += GetDynamicSize(source);");
            }

            sb.AppendLine("            return size;");
            sb.AppendLine("        }");
            
            sb.AppendLine($"        public static int GetNativeHeadSize()");
            sb.AppendLine("        {");
            sb.AppendLine($"            return Unsafe.SizeOf<{type.Name}_Native>();");
            sb.AppendLine("        }");
            
            if (hasDynamic)
            {
                sb.AppendLine();
                sb.AppendLine($"        private static int GetDynamicSize(in {type.Name} source)");
                sb.AppendLine("        {");
                sb.AppendLine($"            int currentOffset = Unsafe.SizeOf<{type.Name}_Native>();");
                sb.AppendLine($"            int startOffset = currentOffset;");
                 
                foreach (var field in type.Fields)
                {
                   if (IsDynamic(field))
                   {
                       EmitFieldDynamicSize(sb, field);
                   }
                }
                
                sb.AppendLine($"            return currentOffset - startOffset;");
                sb.AppendLine("        }");
            }
        }

        private bool IsDynamic(FieldInfo field)
        {
            if (field.TypeName == "string" || field.TypeName == "System.String") return true;
            if (field.TypeName.StartsWith("List<") || field.TypeName.EndsWith("[]") || field.TypeName.StartsWith("System.Collections.Generic.List<")) return true;
            
            TypeInfo? fieldType = field.Type;
            if (fieldType == null && _registry != null && _registry.TryGetDefinition(field.TypeName, out var def))
            {
                fieldType = def.TypeInfo;
            }

            if (fieldType != null && fieldType.IsStruct && !fieldType.IsEnum) return true;
            if (fieldType != null && fieldType.IsUnion) return true;
            if (fieldType != null && fieldType.IsTopic) return true;
            if (IsOptional(field)) return true;
            return false;
        }

        private void EmitFieldDynamicSize(StringBuilder sb, FieldInfo field)
        {
             string typeName = field.TypeName;
             
             // Resolve TypeInfo if missing
             TypeInfo? fieldType = field.Type;
             if (fieldType == null && _registry != null && _registry.TryGetDefinition(field.TypeName, out var def))
             {
                 fieldType = def.TypeInfo;
             }
             
             if (typeName == "string" || typeName == "System.String")
             {
                 sb.AppendLine($"            if (source.{field.Name} != null)"); 
                 sb.AppendLine($"            {{");
                 sb.AppendLine($"                currentOffset = (currentOffset + 7) & ~7;");
                 sb.AppendLine($"                currentOffset += DdsTextEncoding.GetUtf8Size(source.{field.Name});");
                 sb.AppendLine($"            }}");
             }
             else if (typeName.StartsWith("List<") || typeName.EndsWith("[]") || typeName.StartsWith("System.Collections.Generic.List<"))
             {
                 sb.AppendLine($"            if (source.{field.Name} != null && source.{field.Name}.Count > 0)");
                 sb.AppendLine($"            {{");
                 sb.AppendLine($"                currentOffset = (currentOffset + 7) & ~7;");
                 
                 string elementType = ExtractGenericType(typeName);
                 if (IsPrimitive(elementType))
                 {
                      string nativeType = elementType;
                      if (nativeType == "bool") nativeType = "byte";
                      if (nativeType == "string" || nativeType == "System.String") nativeType = "IntPtr"; 
                      
                      sb.AppendLine($"                currentOffset += source.{field.Name}.Count * Unsafe.SizeOf<{nativeType}>();");
                 }
                 else
                 {
                      string nativeElem = GetNativeTypeForSequenceElement(field);
                      
                      sb.AppendLine($"                currentOffset += source.{field.Name}.Count * Unsafe.SizeOf<{nativeElem}>();");
                      sb.AppendLine($"                foreach(var item in source.{field.Name})");
                      sb.AppendLine("                {");
                      string managedType = ExtractGenericType(typeName); 
                      
                      if (managedType == "string" || managedType == "System.String")
                      {
                           sb.AppendLine($"                    currentOffset = (currentOffset + 7) & ~7;");
                           sb.AppendLine($"                    currentOffset += DdsTextEncoding.GetUtf8Size(item);");
                      }
                      else
                      {
                           sb.AppendLine($"                    currentOffset = (currentOffset + 7) & ~7;");
                           sb.AppendLine($"                    currentOffset += {managedType}.GetNativeSize(item) - Unsafe.SizeOf<{nativeElem}>();");
                      }
                      sb.AppendLine("                }");
                 }
                 sb.AppendLine($"            }}");
             }
             else if (fieldType != null && (fieldType.IsStruct || fieldType.IsUnion || fieldType.IsTopic) && !fieldType.IsEnum)
             {
                 // Nested Struct or Union
                 string fullTypeName = fieldType.FullName;
                 if (IsOptional(field))
                 {
                     sb.AppendLine($"            if (source.{field.Name} != null)");
                     sb.AppendLine($"            {{");
                     sb.AppendLine($"                currentOffset = (currentOffset + 7) & ~7;");
                     sb.AppendLine($"                currentOffset += {fullTypeName}.GetNativeSize(source.{field.Name}.Value);");
                     sb.AppendLine($"            }}");
                 }
                 else
                 {
                     sb.AppendLine($"            var __{field.Name}_dyn = {fullTypeName}.GetNativeSize(source.{field.Name}) - Unsafe.SizeOf<{fullTypeName}_Native>();");
                     sb.AppendLine($"            if (__{field.Name}_dyn > 0)");
                     sb.AppendLine($"            {{");
                     sb.AppendLine($"                currentOffset = (currentOffset + 7) & ~7;");
                     sb.AppendLine($"                currentOffset += __{field.Name}_dyn;");
                     sb.AppendLine($"            }}");
                 }
             }
             else if (IsOptional(field))
             {
                 string baseType = field.TypeName.TrimEnd('?');
                 if (baseType == "bool" || baseType == "Boolean" || baseType == "System.Boolean") baseType = "byte";

                 sb.AppendLine($"            if (source.{field.Name}.HasValue)");
                 sb.AppendLine($"            {{");
                 sb.AppendLine($"                currentOffset = (currentOffset + 7) & ~7;");
                 sb.AppendLine($"                currentOffset += Unsafe.SizeOf<{baseType}>();");
                 sb.AppendLine($"            }}");
             }
        }
        
        private string GetNativeTypeForSequenceElement(FieldInfo field)
        {
             string elementType = ExtractGenericType(field.TypeName);
             if (IsPrimitive(elementType))
             {
                 if (elementType == "bool" || elementType == "Boolean" || elementType == "System.Boolean") return "byte";
                 return elementType;
             }
             // For strings? List<string>.
             if (elementType == "string") return "IntPtr";
             
             // User type
             return elementType + "_Native";
        }

        private string ToPascalCase(string name)
        {
            if (string.IsNullOrEmpty(name)) return name;
            return char.ToUpper(name[0]) + name.Substring(1);
        }

        private int? GetMaxLength(FieldInfo field)
        {
            var attr = field.GetAttribute("MaxLength");
            if (attr != null && attr.Arguments.Count > 0)
            {
                if (attr.Arguments[0] is int i) return i;
            }
            return null;
        }

        private int GetAlignment(FieldInfo field)
        {
             if (IsOptional(field)) return 8;

             // Bounded strings are inline arrays (char[N]), alignment 1
             if ((field.TypeName == "string" || field.TypeName == "System.String") && GetMaxLength(field).HasValue)
             {
                 return 1;
             }

             string name = field.TypeName;
             if (name.StartsWith("System.")) name = name.Substring(7);
             
             // Arrays/Lists/Strings -> 8 bytes (pointers/structs with pointers)
             if (name == "string" || name == "String" || name == "IntPtr" || 
                 name.StartsWith("List<") || name.EndsWith("[]") || name.StartsWith("BoundedSeq") || name.StartsWith("System.Collections.Generic.List<")) 
                 return 8;

             // Primitive checks
             var lower = name.ToLower();
             if (lower == "double" || lower == "long" || lower == "int64" || lower == "ulong" || lower == "uint64") return 8;
             if (lower == "int" || lower == "int32" || lower == "uint" || lower == "uint32" || lower == "float" || lower == "single") return 4;
             if (lower == "short" || lower == "int16" || lower == "ushort" || lower == "uint16" || lower == "char") return 2;
             if (lower == "byte" || lower == "sbyte" || lower == "bool" || lower == "boolean" || lower == "uint8" || lower == "int8") return 1;

             // Complex types
             TypeInfo? fieldType = field.Type;
             if (fieldType == null && _registry != null && _registry.TryGetDefinition(field.TypeName, out var def))
             {
                 fieldType = def.TypeInfo;
             }
             
             if (fieldType != null)
             {
                 if (fieldType.IsEnum) return 4; 
                 if (fieldType.IsStruct || fieldType.IsUnion)
                 {
                     int max = 1;
                     foreach(var f in fieldType.Fields)
                     {
                         int a = GetAlignment(f);
                         if (a > max) max = a;
                     }
                     return max;
                 }
             }
             
             return 1;
        }

        private void EmitGhostStruct(StringBuilder sb, TypeInfo type)
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Native C-compatible struct for {type.Name}.");
            sb.AppendLine("    /// </summary>");
            
            if (type.HasAttribute("DdsUnion"))
            {
                // Explicit layout for Unions (Wrapper)
                sb.AppendLine("    [StructLayout(LayoutKind.Explicit)]");
                sb.AppendLine($"    internal unsafe struct {type.Name}_Native");
                sb.AppendLine("    {");

                var discriminator = type.Fields.FirstOrDefault(f => f.HasAttribute("DdsDiscriminator"));
                string discType = "int";
                int discSize = 4;
                
                if (discriminator != null)
                {
                     discType = GetNativeType(discriminator);
                     if (discType == "byte") discSize = 1;
                     else if (discType == "short" || discType == "ushort") discSize = 2;
                }

                sb.AppendLine($"        [FieldOffset(0)]");
                sb.AppendLine($"        public {discType} _d;");

                // Calculate max alignment of members
                int maxAlign = 1;
                foreach(var field in type.Fields)
                {
                    if (field == discriminator) continue;
                    int a = GetAlignment(field);
                    if (a > maxAlign) maxAlign = a;
                }
                
                // Align offset
                int offset = (discSize + (maxAlign - 1)) & ~(maxAlign - 1);
                
                sb.AppendLine($"        [FieldOffset({offset})]");
                sb.AppendLine($"        public {type.Name}_Union_Native _u;");
                sb.AppendLine("    }");

                // Union Payload (Explicit, all 0)
                sb.AppendLine();
                sb.AppendLine("    [StructLayout(LayoutKind.Explicit)]");
                sb.AppendLine($"    internal unsafe struct {type.Name}_Union_Native");
                sb.AppendLine("    {");
                foreach (var field in type.Fields)
                {
                    if (field.HasAttribute("DdsDiscriminator")) continue;

                    int? maxLen = GetMaxLength(field);
                    if (maxLen.HasValue && (field.TypeName == "string" || field.TypeName == "System.String"))
                    {
                        sb.AppendLine($"        [FieldOffset(0)]");
                        sb.AppendLine($"        public fixed byte {field.Name}[{maxLen.Value + 1}];");
                    }
                    else
                    {
                        string nativeType = GetNativeType(field);
                        sb.AppendLine($"        [FieldOffset(0)]");
                        sb.AppendLine($"        public {nativeType} {field.Name};");
                    }
                }
                sb.AppendLine("    }");
            }
            else
            {
                sb.AppendLine("    [StructLayout(LayoutKind.Sequential)]");
                sb.AppendLine($"    internal unsafe struct {type.Name}_Native");
                sb.AppendLine("    {");
                foreach (var field in type.Fields)
                {
                    int? maxLen = GetMaxLength(field);
                    if (maxLen.HasValue && (field.TypeName == "string" || field.TypeName == "System.String"))
                    {
                        sb.AppendLine($"        public fixed byte {field.Name}[{maxLen.Value + 1}];");
                    }
                    else
                    {
                        string nativeType = GetNativeType(field);
                        sb.AppendLine($"        public {nativeType} {field.Name};");
                    }
                }
                sb.AppendLine("    }");
            }
        }

        private string GetNativeType(FieldInfo field)
        {
            string baseType = GetBaseType(field.TypeName);
            if (IsOptional(field)) return "IntPtr";
            
            if (field.TypeName == "bool" || field.TypeName == "Boolean" || field.TypeName == "System.Boolean") return "byte";
            if (baseType == "string" || baseType == "System.String") return "IntPtr";
            
            if (field.TypeName.StartsWith("List<") || field.TypeName.StartsWith("System.Collections.Generic.List<") || field.TypeName.EndsWith("[]") || field.TypeName.StartsWith("BoundedSeq"))
            {
                return "DdsSequenceNative";
            }
            
            if (field.Type != null)
            {
                if (field.Type.IsEnum) return field.TypeName;
                return $"{field.Type.FullName}_Native";
            }
            
            // Primitives
            return field.TypeName;
        }
    }
}
