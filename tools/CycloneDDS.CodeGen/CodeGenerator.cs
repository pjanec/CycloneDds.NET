using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using CycloneDDS.Schema;
using CycloneDDS.Compiler.Common;
using CycloneDDS.Compiler.Common.IdlJson;
using CycloneDDS.CodeGen.Emitters;

namespace CycloneDDS.CodeGen
{
    public class CodeGenerator
    {
        private readonly SchemaDiscovery _discovery = new SchemaDiscovery();
        private readonly IdlEmitter _idlEmitter = new IdlEmitter();
        private readonly SerializerEmitter _serializerEmitter = new SerializerEmitter();
        private readonly ViewEmitter _viewEmitter = new ViewEmitter();
        private readonly ViewExtensionsEmitter _viewExtensionsEmitter = new ViewExtensionsEmitter();

        public void Generate(string sourceDir, string outputDir, IEnumerable<string>? referencePaths = null)
        {
            var types = _discovery.DiscoverTopics(sourceDir, referencePaths);
            var validator = new SchemaValidator(types, _discovery.ValidExternalTypes);
            var managedValidator = new ManagedTypeValidator();
            
            bool hasErrors = false;
            var allErrors = new List<string>();

            foreach (var type in types)
            {
                var result = validator.Validate(type);
                if (!result.IsValid)
                {
                    hasErrors = true;
                    allErrors.AddRange(result.Errors);
                    foreach (var err in result.Errors) Console.Error.WriteLine($"ERROR: {err}");
                }

                var managedErrors = managedValidator.Validate(type);
                if (managedErrors.Any(d => d.Severity == ValidationSeverity.Error))
                {
                    hasErrors = true;
                    allErrors.AddRange(managedErrors.Where(d => d.Severity == ValidationSeverity.Error).Select(d => d.Message));
                    foreach (var d in managedErrors.Where(d => d.Severity == ValidationSeverity.Error))
                        Console.Error.WriteLine($"ERROR: {d.Message}");
                }
            }
            
            if (hasErrors)
            {
                throw new InvalidOperationException("Schema validation failed. Fix errors above.\nErrors:\n" + string.Join("\n", allErrors));
            }
            
            if (!Directory.Exists(outputDir)) Directory.CreateDirectory(outputDir);

            var validFiles = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            // Phase 1: Registry Population
            var registry = new GlobalTypeRegistry();
            foreach (var type in types)
            {
                var idlFile = _discovery.GetIdlFileName(type, type.SourceFile);
                var idlModule = _discovery.GetIdlModule(type);
                registry.RegisterLocal(type, type.SourceFile, idlFile, idlModule);
            }

            // Phase 2: Dependency Resolution
            ResolveExternalDependencies(registry, types);
            
            // Phase 3: Emit IDL (Grouped)
            _idlEmitter.EmitIdlFiles(registry, outputDir);
            
            // Emit Assembly Metadata
            validFiles.Add(EmitAssemblyMetadata(registry, outputDir));
            
            // Phase 4: Generate Descriptors (Parse JSON from idlc)
            var descriptors = GetDescriptorsFromIdlc(registry, outputDir);

            // Phase 5: Emit Combined C# Code
            foreach (var topic in types)
            {
                if (topic.IsTopic || topic.IsStruct || topic.IsUnion)
                {
                    var safeName = topic.FullName;
                    if (safeName.StartsWith("<global namespace>.")) safeName = safeName.Replace("<global namespace>.", "");
                    safeName = safeName.Replace("<", "_").Replace(">", "_");

                    var sb = new StringBuilder();
                    sb.AppendLine("// <auto-generated />");
                    sb.AppendLine("#pragma warning disable CS0162, CS0219, CS8600, CS8601, CS8602, CS8603, CS8604, CS8605, CS8618, CS8625");
                    
                    sb.AppendLine("using System;");
                    sb.AppendLine("using System.Runtime.InteropServices;");
                    sb.AppendLine("using System.Runtime.CompilerServices;");
                    sb.AppendLine("using System.Text;");
                    sb.AppendLine("using System.Linq;");
                    sb.AppendLine("using System.Collections.Generic;");
                    sb.AppendLine("using CycloneDDS.Core;");
                    sb.AppendLine("using CycloneDDS.Runtime;");
                    sb.AppendLine();

                    sb.AppendLine(_serializerEmitter.EmitSerializer(topic, registry, false));
                    sb.AppendLine(_viewEmitter.EmitViewStruct(topic, registry, false));
                    sb.AppendLine(_viewExtensionsEmitter.EmitExtensions(topic, registry, false));

                    if (descriptors.TryGetValue(topic.FullName, out var descriptor))
                    {
                        sb.AppendLine(GenerateDescriptorCodeFromJson(topic, descriptor, false));
                    }
                    else if (!topic.IsEnum)
                    {
                        Console.WriteLine($"    Warning: No topic descriptor found for {topic.Name}");
                    }

                    string filePath = Path.Combine(outputDir, $"{safeName}.g.cs");
                    WriteIfChanged(filePath, sb.ToString());
                    validFiles.Add(filePath);
                }
            }

            // Phase 6: Clean up old scattered .cs files (like .Serializer.cs, .Deserializer.cs)
            foreach (var file in Directory.GetFiles(outputDir, "*.cs", SearchOption.TopDirectoryOnly))
            {
                if (!validFiles.Contains(file))
                {
                    File.Delete(file);
                }
            }
        }

        private void WriteIfChanged(string path, string content)
        {
            if (File.Exists(path))
            {
                var existing = File.ReadAllText(path);
                if (existing == content) return;
            }
            File.WriteAllText(path, content);
        }

        private void ResolveExternalDependencies(GlobalTypeRegistry registry, List<TypeInfo> types)
        {
            var resolvedCache = new HashSet<string>();

            foreach(var type in types)
            {
                foreach(var field in type.Fields)
                {
                    var fieldTypeName = StripGenerics(field.TypeName);
                    if (registry.TryGetDefinition(fieldTypeName, out _)) continue;
                    if (resolvedCache.Contains(fieldTypeName)) continue;
                    var extDef = ResolveExternalType(_discovery.Compilation, fieldTypeName);
                    if (extDef != null)
                    {
                        if (!registry.TryGetDefinition(extDef.CSharpFullName, out _))
                        {
                            registry.RegisterExternal(extDef.CSharpFullName, extDef.TargetIdlFile, extDef.TargetModule, extDef.TypeInfo);
                            resolvedCache.Add(fieldTypeName);
                        }
                    }
                }
            }
        }

        private IdlTypeDefinition? ResolveExternalType(Compilation? compilation, string fullTypeName)
        {
            if (compilation == null) return null;
            var symbol = compilation.GetTypeByMetadataName(fullTypeName);
            if (symbol == null || symbol.Locations.Any(loc => loc.IsInSource)) return null; 
            var assembly = symbol.ContainingAssembly;
            if (assembly == null) return null;
            foreach (var attr in assembly.GetAttributes())
            {
                if (attr.AttributeClass?.Name == "DdsIdlMappingAttribute" || attr.AttributeClass?.Name == "DdsIdlMapping")
                {
                     if (attr.ConstructorArguments.Length >= 3)
                     {
                         string? mappedType = attr.ConstructorArguments[0].Value as string;
                         if (mappedType != null && mappedType == fullTypeName)
                         {
                             string? idlFile = attr.ConstructorArguments[1].Value as string;
                             string? idlModule = attr.ConstructorArguments[2].Value as string;
                             if (idlFile != null && idlModule != null)
                             {
                                 var typeInfo = new TypeInfo
                                 {
                                     Name = symbol.Name,
                                     Namespace = (symbol.ContainingNamespace?.ToDisplayString() ?? "").Replace("<global namespace>", "").Trim('.')
                                 };
                                 var symAttrs = symbol.GetAttributes();
                                 if (symAttrs.Any(a => a.AttributeClass?.Name == "DdsStructAttribute" || a.AttributeClass?.Name == "DdsStruct"))
                                     typeInfo.IsStruct = true;
                                 if (symAttrs.Any(a => a.AttributeClass?.Name == "DdsUnionAttribute" || a.AttributeClass?.Name == "DdsUnion"))
                                     typeInfo.IsUnion = true;
                                 if (symAttrs.Any(a => a.AttributeClass?.Name == "DdsTopicAttribute" || a.AttributeClass?.Name == "DdsTopic"))
                                     typeInfo.IsTopic = true;
                                 if (symbol.TypeKind == TypeKind.Enum) typeInfo.IsEnum = true;
                                 
                                 return new IdlTypeDefinition { CSharpFullName = fullTypeName, TargetIdlFile = idlFile, TargetModule = idlModule, IsExternal = true, TypeInfo = typeInfo };
                             }
                         }
                     }
                }
            }
            return null;
        }

        private string EmitAssemblyMetadata(GlobalTypeRegistry registry, string outputDir)
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using CycloneDDS.Schema;");
            sb.AppendLine("using System.Reflection;");
            sb.AppendLine();
            
            foreach (var type in registry.LocalTypes)
            {
                sb.AppendLine($"[assembly: DdsIdlMapping(\"{type.CSharpFullName}\", \"{type.TargetIdlFile}\", \"{type.TargetModule}\")]");
            }
            
            string filePath = Path.Combine(outputDir, "CycloneDDS.IdlMap.g.cs");
            WriteIfChanged(filePath, sb.ToString());
            return filePath;
        }

        private Dictionary<string, JsonTopicDescriptor> GetDescriptorsFromIdlc(GlobalTypeRegistry registry, string outputDir)
        {
            var descriptors = new Dictionary<string, JsonTopicDescriptor>();
            var fileGroups = registry.LocalTypes.Where(t => t.TypeInfo != null).GroupBy(t => t.TargetIdlFile).ToList();

            var idlcRunner = new IdlcRunner();
            var jsonParser = new IdlJsonParser();
            var processedIdlFiles = new HashSet<string>();

            string tempJsonDir = Path.Combine(outputDir, "temp_json");
            if (!Directory.Exists(tempJsonDir)) Directory.CreateDirectory(tempJsonDir);

            foreach (var group in fileGroups)
            {
                string idlFileName = group.Key;
                string idlPath = Path.Combine(outputDir, $"{idlFileName}.idl");
                
                if (!processedIdlFiles.Contains(idlFileName))
                {
                    var result = idlcRunner.RunIdlc(idlPath, tempJsonDir, outputDir);
                    if (result.ExitCode != 0)
                    {
                         throw new InvalidOperationException($"idlc generated failed for {idlFileName} (exit {result.ExitCode}). Stderr: {result.StandardError}. Stdout: {result.StandardOutput}");
                    }
                    processedIdlFiles.Add(idlFileName);
                }
            }
            
            foreach (var group in fileGroups)
            {
                string idlFileName = group.Key;
                string jsonFile = Path.Combine(tempJsonDir, $"{idlFileName}.json");
                
                if (File.Exists(jsonFile))
                {
                    try
                    {
                        var jsonTypes = jsonParser.Parse(jsonFile);
                        foreach(var topic in group)
                        {
                            if (topic.TypeInfo == null || topic.TypeInfo.IsEnum) continue;
                            string idlName = topic.CSharpFullName.Replace(".", "::");
                            var jsonDef = jsonParser.FindType(jsonTypes, idlName);
                            if (jsonDef != null && jsonDef.TopicDescriptor != null)
                            {
                                descriptors[topic.CSharpFullName] = jsonDef.TopicDescriptor;
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.Error.WriteLine($"    JSON parsing failed for {idlFileName}: {ex.Message}");
                    }
                }
            }
            return descriptors;
        }

        private string GenerateDescriptorCodeFromJson(TypeInfo topic, JsonTopicDescriptor descriptor, bool generateUsings = true)
        {
            var sb = new System.Text.StringBuilder();
            if (generateUsings)
            {
                sb.AppendLine("using System;");
                sb.AppendLine("using CycloneDDS.Runtime;");
                sb.AppendLine();
            }
            
            if (!string.IsNullOrEmpty(topic.Namespace))
            {
                sb.AppendLine($"namespace {topic.Namespace}");
                sb.AppendLine("{");
            }
            
            string typeKind = topic.IsClass ? "class" : "struct";
            sb.AppendLine($"    public partial {typeKind} {topic.Name}");
            sb.AppendLine("    {");
            
            sb.Append("        private static readonly uint[] _ops = new uint[] { ");
            if (descriptor.Ops != null && descriptor.Ops.Length > 0)
            {
                sb.Append(string.Join(", ", descriptor.Ops.Select(op => (uint)op)));
            }
            sb.AppendLine(" };");
            sb.AppendLine("        public static uint[] GetDescriptorOps() => _ops;");

            if (descriptor.Keys != null && descriptor.Keys.Count > 0)
            {
                var keyIndices = CalculateKeyOpIndices(descriptor.Ops!, descriptor.Keys);

                sb.AppendLine();
                sb.AppendLine("        private static readonly DdsKeyDescriptor[] _keys = new DdsKeyDescriptor[]");
                sb.AppendLine("        {");
                foreach(var key in descriptor.Keys)
                {
                    var field = topic.Fields.FirstOrDefault(f => string.Equals(f.Name, key.Name, StringComparison.OrdinalIgnoreCase));
                    string fieldName = field != null ? field.Name : key.Name;
                    uint opIndex = keyIndices.ContainsKey(key.Name) ? keyIndices[key.Name] : 0;
                    sb.AppendLine($"            new DdsKeyDescriptor {{ Name = \"{fieldName}\", Offset = {opIndex}, Index = {key.Order} }},");
                }
                sb.AppendLine("        };");
                sb.AppendLine("        public static DdsKeyDescriptor[] GetKeyDescriptors() => _keys;");
            }
            else
            {
                sb.AppendLine("        public static DdsKeyDescriptor[] GetKeyDescriptors() => null;");
            }

            sb.AppendLine();
            sb.AppendLine($"        public static uint GetDescriptorFlagset() => {descriptor.FlagSet};");
            sb.AppendLine($"        public static uint GetDescriptorSize() => {descriptor.Size};");
            sb.AppendLine($"        public static uint GetDescriptorAlign() => {descriptor.Align};");
            sb.AppendLine("    }");
            
            if (!string.IsNullOrEmpty(topic.Namespace)) sb.AppendLine("}");
            return sb.ToString(); 
        }

        private string StripGenerics(string typeName)
        {
            int idx = typeName.IndexOf('<');
            if (idx > 0)
            {
                if (typeName.StartsWith("System.Collections.Generic.List") || typeName.StartsWith("List"))
                {
                    int end = typeName.LastIndexOf('>');
                    return typeName.Substring(idx + 1, end - idx - 1).Trim();
                }
            }
            return typeName.TrimEnd('?');
        }

        private Dictionary<string, uint> CalculateKeyOpIndices(long[] ops, List<JsonKeyDescriptor> keys)
        {
            var result = new Dictionary<string, uint>();
            if (ops == null || ops.Length == 0 || keys == null || keys.Count == 0) return result;
            
            var sortedKeys = keys.OrderBy(k => k.Order).ToList();
            int currentKeyIndex = 0;

            for (int i = 0; i < ops.Length; i++)
            {
                uint op = (uint)ops[i];
                uint opcode = (op & 0xFF000000);

                if (opcode == 0x07000000) // DDS_OP_KOF
                {
                    int count = (int)(op & 0x00FFFFFF);
                    if (currentKeyIndex < sortedKeys.Count)
                    {
                        var key = sortedKeys[currentKeyIndex];
                        result[key.Name] = (uint)i;
                        currentKeyIndex++;
                    }
                    i += count;
                }
            }
            return result;
        }
    }
}
