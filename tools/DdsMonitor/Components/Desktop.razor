@page "/"
@implements IDisposable

@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using System.Reflection
@using System.IO

@inject IWindowManager WindowManager
@inject IWorkspaceState WorkspaceState
@inject IJSRuntime JSRuntime

<div class="desktop" @ref="_desktopRef" @onmousemove="HandleMouseMove" @onmouseup="EndDrag" @onmouseleave="EndDrag">
    @foreach (var panel in WindowManager.ActivePanels)
    {
        if (panel.IsMinimized || panel.IsHidden)
        {
            continue;
        }

        <div class="panel" style="@GetPanelStyle(panel)" @onmousedown="() => BringToFront(panel)">
            <div class="panel-titlebar" @onmousedown="(e) => BeginDrag(panel, e)">
                <span class="panel-title">@panel.Title</span>
                <div class="panel-actions" @onmousedown:stopPropagation="true">
                    <button type="button" class="panel-btn" @onclick="() => ToggleMinimize(panel)" @onclick:stopPropagation="true">_</button>
                    <button type="button" class="panel-btn" @onclick="() => ClosePanel(panel)" @onclick:stopPropagation="true">x</button>
                </div>
            </div>
            <div class="panel-body">
                @RenderPanelBody(panel)
            </div>

            <div class="resize-handle handle-top" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Top, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-right" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Right, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-bottom" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Bottom, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-left" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Left, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-top-left" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Top | ResizeEdge.Left, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-top-right" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Top | ResizeEdge.Right, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-bottom-left" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Bottom | ResizeEdge.Left, e)" @onmousedown:stopPropagation="true"></div>
            <div class="resize-handle handle-bottom-right" @onmousedown="(e) => BeginResize(panel, ResizeEdge.Bottom | ResizeEdge.Right, e)" @onmousedown:stopPropagation="true"></div>
        </div>
    }

    <div class="panel-strip">
        @foreach (var panel in WindowManager.ActivePanels)
        {
            if (!panel.IsMinimized || panel.IsHidden)
            {
                continue;
            }

            <button type="button" class="panel-strip-item" @onclick="() => RestorePanel(panel)">
                @panel.Title
            </button>
        }
    </div>
</div>

@code {
    private const double MinPanelWidth = 220;
    private const double MinPanelHeight = 140;
    private static readonly string TopicExplorerTypeName = typeof(TopicExplorerPanel).AssemblyQualifiedName!;

    private PanelState? _activePanel;
    private DragMode _dragMode = DragMode.None;
    private ResizeEdge _resizeEdge = ResizeEdge.None;
    private double _startMouseX;
    private double _startMouseY;
    private double _startX;
    private double _startY;
    private double _startWidth;
    private double _startHeight;
    private ElementReference _desktopRef;
    private DesktopSize? _desktopSize;
    private bool _pendingClamp = true;
    private bool _isLoadingWorkspace;

    protected override void OnInitialized()
    {
        WindowManager.PanelsChanged += HandlePanelsChanged;
        LoadWorkspace();
        EnsureTopicsPanel();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || _pendingClamp)
        {
            _pendingClamp = false;
            await EnsurePanelsVisibleAsync();
        }
    }

    private void HandlePanelsChanged()
    {
        // Ensure panels are visible after changes (e.g. loading workspace or restore)
        _ = InvokeAsync(async () =>
        {
            await EnsurePanelsVisibleAsync();
            StateHasChanged();
        });

        if (!_isLoadingWorkspace)
        {
            SaveWorkspace();
        }
    }

    private async Task EnsurePanelsVisibleAsync()
    {
        if (!await RefreshDesktopSizeAsync())
        {
            return;
        }

        const double minMargin = 12;

        var maxWidth = Math.Max(MinPanelWidth, _desktopSize!.Width - (minMargin * 2));
        var maxHeight = Math.Max(MinPanelHeight, _desktopSize!.Height - (minMargin * 2));

        foreach (var panel in WindowManager.ActivePanels)
        {
            if (panel == null || panel.IsHidden)
            {
                continue;
            }

            panel.Width = ClampSize(panel.Width, MinPanelWidth, maxWidth);
            panel.Height = ClampSize(panel.Height, MinPanelHeight, maxHeight);

            panel.X = Clamp(panel.X, minMargin, _desktopSize.Width - panel.Width - minMargin);
            panel.Y = Clamp(panel.Y, minMargin, _desktopSize.Height - panel.Height - minMargin);
        }
    }

    private void EnsureTopicsPanel()
    {
        foreach (var panel in WindowManager.ActivePanels)
        {
            if (string.Equals(panel.ComponentTypeName, TopicExplorerTypeName, StringComparison.Ordinal))
            {
                return;
            }
        }

        var panelState = WindowManager.SpawnPanel(TopicExplorerTypeName);
        panelState.Title = "Topics";
        SaveWorkspace();
    }

    private void BeginDrag(PanelState panel, MouseEventArgs args)
    {
        BringToFront(panel);
        _activePanel = panel;
        _dragMode = DragMode.Move;
        _startMouseX = args.ClientX;
        _startMouseY = args.ClientY;
        _startX = panel.X;
        _startY = panel.Y;
    }

    private void BeginResize(PanelState panel, ResizeEdge edge, MouseEventArgs args)
    {
        BringToFront(panel);
        _activePanel = panel;
        _dragMode = DragMode.Resize;
        _resizeEdge = edge;
        _startMouseX = args.ClientX;
        _startMouseY = args.ClientY;
        _startX = panel.X;
        _startY = panel.Y;
        _startWidth = panel.Width;
        _startHeight = panel.Height;
    }

    private void HandleMouseMove(MouseEventArgs args)
    {
        if (_activePanel == null || _dragMode == DragMode.None)
        {
            return;
        }

        var deltaX = args.ClientX - _startMouseX;
        var deltaY = args.ClientY - _startMouseY;

        if (_dragMode == DragMode.Move)
        {
            _activePanel.X = _startX + deltaX;
            _activePanel.Y = _startY + deltaY;
        }
        else if (_dragMode == DragMode.Resize)
        {
            ApplyResize(_activePanel, deltaX, deltaY);
        }

        StateHasChanged();
    }

    private void EndDrag()
    {
        if (_dragMode == DragMode.None)
        {
            return;
        }

        var panel = _activePanel;

        _dragMode = DragMode.None;
        _resizeEdge = ResizeEdge.None;
        _activePanel = null;

        if (panel != null)
        {
            _ = InvokeAsync(async () =>
            {
                await ClampPanelToDesktopAsync(panel);
                SaveWorkspace();
                StateHasChanged();
            });
        }
    }

    private void ApplyResize(PanelState panel, double deltaX, double deltaY)
    {
        if (_resizeEdge.HasFlag(ResizeEdge.Right))
        {
            panel.Width = Math.Max(MinPanelWidth, _startWidth + deltaX);
        }

        if (_resizeEdge.HasFlag(ResizeEdge.Left))
        {
            var proposed = _startWidth - deltaX;
            var clamped = Math.Max(MinPanelWidth, proposed);
            panel.Width = clamped;
            panel.X = _startX + (_startWidth - clamped);
        }

        if (_resizeEdge.HasFlag(ResizeEdge.Bottom))
        {
            panel.Height = Math.Max(MinPanelHeight, _startHeight + deltaY);
        }

        if (_resizeEdge.HasFlag(ResizeEdge.Top))
        {
            var proposed = _startHeight - deltaY;
            var clamped = Math.Max(MinPanelHeight, proposed);
            panel.Height = clamped;
            panel.Y = _startY + (_startHeight - clamped);
        }
    }

    private void BringToFront(PanelState panel)
    {
        WindowManager.BringToFront(panel.PanelId);
    }

    private void ToggleMinimize(PanelState panel)
    {
        panel.IsMinimized = !panel.IsMinimized;
        SaveWorkspace();
    }

    private void RestorePanel(PanelState panel)
    {
        panel.IsMinimized = false;
        // Ensure restored panels have their titlebar visible
        const double minMargin = 12;
        if (double.IsNaN(panel.X) || panel.X < minMargin) panel.X = minMargin;
        if (double.IsNaN(panel.Y) || panel.Y < minMargin) panel.Y = minMargin;
        BringToFront(panel);
        SaveWorkspace();
    }

    private async Task ClampPanelToDesktopAsync(PanelState panel)
    {
        if (panel == null)
        {
            return;
        }

        if (!await RefreshDesktopSizeAsync())
        {
            return;
        }

        const double minMargin = 12;
        var maxWidth = Math.Max(MinPanelWidth, _desktopSize!.Width - (minMargin * 2));
        var maxHeight = Math.Max(MinPanelHeight, _desktopSize!.Height - (minMargin * 2));

        panel.Width = ClampSize(panel.Width, MinPanelWidth, maxWidth);
        panel.Height = ClampSize(panel.Height, MinPanelHeight, maxHeight);
        panel.X = Clamp(panel.X, minMargin, _desktopSize.Width - panel.Width - minMargin);
        panel.Y = Clamp(panel.Y, minMargin, _desktopSize.Height - panel.Height - minMargin);
    }

    private async Task<bool> RefreshDesktopSizeAsync()
    {
        var size = await JSRuntime.InvokeAsync<DesktopSize?>("ddsMonitor.getElementSize", _desktopRef);
        if (size == null || size.Width <= 0 || size.Height <= 0)
        {
            return false;
        }

        _desktopSize = size;
        return true;
    }

    private static double Clamp(double value, double min, double max)
    {
        if (double.IsNaN(value))
        {
            return min;
        }

        if (max < min)
        {
            return min;
        }

        if (value < min)
        {
            return min;
        }

        return value > max ? max : value;
    }

    private static double ClampSize(double value, double min, double max)
    {
        if (double.IsNaN(value) || value <= 0)
        {
            return min;
        }

        if (max < min)
        {
            return min;
        }

        if (value < min)
        {
            return min;
        }

        return value > max ? max : value;
    }

    private void ClosePanel(PanelState panel)
    {
        WindowManager.ClosePanel(panel.PanelId);
        SaveWorkspace();
    }

    private void LoadWorkspace()
    {
        var filePath = WorkspaceState.WorkspaceFilePath;
        if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
        {
            return;
        }

        try
        {
            _isLoadingWorkspace = true;
            WindowManager.LoadWorkspace(filePath);
        }
        finally
        {
            _isLoadingWorkspace = false;
        }
    }

    private void SaveWorkspace()
    {
        var filePath = WorkspaceState.WorkspaceFilePath;
        if (string.IsNullOrWhiteSpace(filePath))
        {
            return;
        }

        try
        {
            WindowManager.SaveWorkspace(filePath);
        }
        catch
        {
            // Ignore persistence errors to avoid breaking the UI loop.
        }
    }

    private RenderFragment RenderPanelBody(PanelState panel) => builder =>
    {
        var componentType = ResolveComponentType(panel.ComponentTypeName);
        if (componentType != null)
        {
            builder.OpenComponent<CascadingValue<PanelState>>(0);
            builder.AddAttribute(1, "Value", panel);
            builder.AddAttribute(2, "IsFixed", true);
            builder.AddAttribute(3, "ChildContent", (RenderFragment)(childBuilder =>
            {
                childBuilder.OpenComponent(0, componentType);
                if (panel.ComponentState.Count > 0)
                {
                    var parameters = FilterComponentParameters(componentType, panel.ComponentState);
                    if (parameters.Count > 0)
                    {
                        childBuilder.AddMultipleAttributes(1, parameters);
                    }
                }
                childBuilder.CloseComponent();
            }));
            builder.CloseComponent();
        }
        else
        {
            builder.OpenElement(2, "div");
            builder.AddAttribute(3, "class", "panel-placeholder");
            builder.AddContent(4, $"Missing component: {panel.ComponentTypeName}");
            builder.CloseElement();
        }
    };

    private static Type? ResolveComponentType(string componentTypeName)
    {
        if (string.IsNullOrWhiteSpace(componentTypeName))
        {
            return null;
        }

        return Type.GetType(componentTypeName);
    }

    private static Dictionary<string, object> FilterComponentParameters(Type componentType, Dictionary<string, object> state)
    {
        var result = new Dictionary<string, object>(StringComparer.Ordinal);
        var parameters = GetParameterNames(componentType);

        foreach (var entry in state)
        {
            if (parameters.Contains(entry.Key))
            {
                result[entry.Key] = entry.Value;
            }
        }

        return result;
    }

    private static HashSet<string> GetParameterNames(Type componentType)
    {
        var set = new HashSet<string>(StringComparer.Ordinal);
        const BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

        foreach (var property in componentType.GetProperties(flags))
        {
            if (property.GetCustomAttribute<ParameterAttribute>() != null)
            {
                set.Add(property.Name);
            }
        }

        return set;
    }

    private static string GetPanelStyle(PanelState panel)
    {
        return FormattableString.Invariant(
            $"left:{panel.X}px; top:{panel.Y}px; width:{panel.Width}px; height:{panel.Height}px; z-index:{panel.ZIndex};");
    }

    private enum DragMode
    {
        None,
        Move,
        Resize
    }

    [Flags]
    private enum ResizeEdge
    {
        None = 0,
        Left = 1,
        Top = 2,
        Right = 4,
        Bottom = 8
    }

    private sealed class DesktopSize
    {
        public double Width { get; set; }
        public double Height { get; set; }
    }

    public void Dispose()
    {
        WindowManager.PanelsChanged -= HandlePanelsChanged;
    }
}
