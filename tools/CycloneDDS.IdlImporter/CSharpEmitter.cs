using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using CycloneDDS.Compiler.Common.IdlJson;

namespace CycloneDDS.IdlImporter;

public class CSharpEmitter
{
    private readonly TypeMapper _typeMapper;
    private HashSet<string> _knownTypes = new HashSet<string>();

    public CSharpEmitter(TypeMapper typeMapper)
    {
        _typeMapper = typeMapper;
    }

    public void GenerateCSharp(List<JsonTypeDefinition> types, string originalIdlFileName, string outputFilePath)
    {
        // 1. Build known types set (full C# names)
        _knownTypes.Clear();
        foreach (var t in types)
        {
            try 
            {
                // Note: GetCSharpNamespace converts "A::B" to "A.B"
                string fullCsName = _typeMapper.GetCSharpNamespace(t.Name);
                _knownTypes.Add(fullCsName);
            }
            catch {}
        }

        var sb = new StringBuilder();
        
        // Header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This file was generated by CycloneDDS.IdlImporter");
        sb.AppendLine($"// Original IDL: {originalIdlFileName}");
        sb.AppendLine($"// Generation Date: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using CycloneDDS.Schema;");
        sb.AppendLine();

        // 2. Group by Namespace
        // specialized grouping that respects nested types
        var typeInfos = types.Select(t => {
            var fullCsName = _typeMapper.GetCSharpNamespace(t.Name);
            var (ns, parents, simpleName) = AnalyzeTypePath(fullCsName);
            return new { Type = t, Namespace = ns, Parents = parents, SimpleName = simpleName };
        }).ToList();

        var typesByNamespace = typeInfos
            .GroupBy(t => t.Namespace)
            .OrderBy(g => g.Key);

        foreach (var group in typesByNamespace)
        {
            var ns = group.Key;
            bool hasNamespace = !string.IsNullOrEmpty(ns);

            if (hasNamespace)
            {
                sb.AppendLine($"namespace {ns}");
                sb.AppendLine("{");
            }
            
            foreach (var item in group)
            {
                // To handle nesting, we wrap the emission in partial structs for parents
                int baseIndent = hasNamespace ? 1 : 0;
                
                // Open parents
                foreach (var parent in item.Parents)
                {
                    string indent = new string(' ', baseIndent * 4);
                    sb.AppendLine($"{indent}public partial struct {parent}");
                    sb.AppendLine($"{indent}{{");
                    baseIndent++;
                }

                EmitType(sb, item.Type, item.SimpleName, baseIndent);

                // Close parents
                for (int i = item.Parents.Count - 1; i >= 0; i--)
                {
                    baseIndent--;
                    string indent = new string(' ', baseIndent * 4);
                    sb.AppendLine($"{indent}}}");
                }
            }

            if (hasNamespace)
            {
                sb.AppendLine("}");
                sb.AppendLine();
            }
        }
        
        File.WriteAllText(outputFilePath, sb.ToString());
    }

    private (string ns, List<string> parents, string simpleName) AnalyzeTypePath(string fullCsName)
    {
        var parts = fullCsName.Split('.');
        if (parts.Length == 0) return ("", new List<string>(), "");
        if (parts.Length == 1) return ("", new List<string>(), parts[0]);

        string currentPath = parts[0];
        int typeStartIndex = -1;

        if (_knownTypes.Contains(currentPath))
        {
            typeStartIndex = 0;
        }
        else
        {
            for (int i = 1; i < parts.Length; i++)
            {
                currentPath += "." + parts[i];
                if (_knownTypes.Contains(currentPath))
                {
                    typeStartIndex = i;
                    break;
                }
            }
        }

        if (typeStartIndex == -1)
        {
            string simple = parts.Last();
            string ns = string.Join(".", parts.Take(parts.Length - 1));
            return (ns, new List<string>(), simple);
        }

        if (typeStartIndex == parts.Length - 1)
        {
            string simple = parts.Last();
            string ns = string.Join(".", parts.Take(parts.Length - 1));
            return (ns, new List<string>(), simple);
        }

        string correctNs = string.Join(".", parts.Take(typeStartIndex));
        
        var parents = new List<string>();
        for (int i = typeStartIndex; i < parts.Length - 1; i++)
        {
            parents.Add(parts[i]);
        }
        
        string simpleName = parts.Last();
        
        return (correctNs, parents, simpleName);
    }
    
    private void EmitType(StringBuilder sb, JsonTypeDefinition type, string simpleName, int indentLevel)
    {
        string indent = new string(' ', indentLevel * 4);
        
        if (type.Kind == "struct")
        {
            EmitStruct(sb, type, simpleName, indent);
        }
        else if (type.Kind == "union")
        {
             EmitUnion(sb, type, simpleName, indent);
        }
        else if (type.Kind == "enum")
        {
            EmitEnum(sb, type, simpleName, indent);
        }
    }

    private void EmitUnion(StringBuilder sb, JsonTypeDefinition type, string typeName, string indent)
    {
        sb.AppendLine($"{indent}[DdsUnion]");
        sb.AppendLine($"{indent}public partial struct {typeName}");
        sb.AppendLine($"{indent}{{");
        
        if (type.Members.Count > 0)
        {
            // Discriminator is always first
            var disc = type.Members[0];
            var (discType, _, _, _) = _typeMapper.MapMember(disc);
            
            sb.AppendLine($"{indent}    [DdsDiscriminator]");
            sb.AppendLine($"{indent}    public {discType} {ToPascalCase(disc.Name)};");
            
            foreach (var member in type.Members.Skip(1))
            {
                EmitUnionMember(sb, member, indent + "    ");
            }
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private void EmitUnionMember(StringBuilder sb, JsonMember member, string indent)
    {
        if (member.Labels != null)
        {
            foreach (var label in member.Labels)
            {
                if (label == "default")
                {
                    sb.AppendLine($"{indent}[DdsDefaultCase]");
                }
                else
                {
                    sb.AppendLine($"{indent}[DdsCase({label})]");
                }
            }
        }
        
        var (csType, isManaged, arrayLen, bound) = _typeMapper.MapMember(member);
        
        if (member.IsOptional) sb.AppendLine($"{indent}[DdsOptional]");
        if (member.Id.HasValue) sb.AppendLine($"{indent}[DdsId({member.Id.Value})]");
        
        if (arrayLen > 0)
        {
            sb.AppendLine($"{indent}[ArrayLength({arrayLen})]");
        }

        if (bound > 0)
        {
            if (csType == "string")
            {
                sb.AppendLine($"{indent}[MaxLength({bound})]");
            }
            else
            {
                sb.AppendLine($"{indent}[MaxLength({bound})]");
            }
        }

        if (isManaged) sb.AppendLine($"{indent}[DdsManaged]");
        
        sb.AppendLine($"{indent}public {csType} {ToPascalCase(member.Name)};");
    }

    private void EmitStruct(StringBuilder sb, JsonTypeDefinition type, string typeName, string indent)
    {
        bool hasIdsKey = type.Members.Any(m => m.IsKey);
        
        if (hasIdsKey)
        {
             sb.AppendLine($"{indent}[DdsTopic(\"{type.Name}\")]"); 
        }
        else
        {
             sb.AppendLine($"{indent}[DdsStruct]");
        }
        
        if (!string.IsNullOrEmpty(type.Extensibility))
        {
            string kind = type.Extensibility.ToLower() switch 
            {
                "final" => "Final",
                "appendable" => "Appendable",
                "mutable" => "Mutable",
                _ => "Final"
            };
            sb.AppendLine($"{indent}[DdsExtensibility(DdsExtensibilityKind.{kind})]");
        }

        sb.AppendLine($"{indent}public partial struct {typeName}");
        sb.AppendLine($"{indent}{{");
        
        foreach (var member in type.Members)
        {
            EmitStructMember(sb, member, indent + "    ");
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private void EmitStructMember(StringBuilder sb, JsonMember member, string indent)
    {
        var (csType, isManaged, arrayLen, bound) = _typeMapper.MapMember(member);
        
        if (member.IsKey) sb.AppendLine($"{indent}[DdsKey]");
        if (member.IsOptional) sb.AppendLine($"{indent}[DdsOptional]");
        if (member.Id.HasValue) sb.AppendLine($"{indent}[DdsId({member.Id.Value})]");
        
        if (arrayLen > 0)
        {
            sb.AppendLine($"{indent}[ArrayLength({arrayLen})]");
        }

        if (bound > 0)
        {
            if (csType == "string")
            {
                sb.AppendLine($"{indent}[MaxLength({bound})]");
            }
            else
            {
                sb.AppendLine($"{indent}[MaxLength({bound})]");
            }
        }

        if (isManaged) sb.AppendLine($"{indent}[DdsManaged]");
        
        sb.AppendLine($"{indent}public {csType} {ToPascalCase(member.Name)};");
    }

    private void EmitEnum(StringBuilder sb, JsonTypeDefinition type, string typeName, string indent)
    {
        sb.AppendLine($"{indent}public enum {typeName} : int");
        sb.AppendLine($"{indent}{{");
        
        for (int i = 0; i < type.Members.Count; i++)
        {
            var m = type.Members[i];
            string comma = (i < type.Members.Count - 1) ? "," : "";
            int val = m.Value ?? (m.Id ?? i);
            sb.AppendLine($"{indent}    {ToPascalCase(m.Name)} = {val}{comma}");
        }

        sb.AppendLine($"{indent}}}");
        sb.AppendLine();
    }

    private string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (name == "_d") return "_d";

        var parts = name.Split('_', StringSplitOptions.RemoveEmptyEntries);
        var sb = new StringBuilder();
        
        foreach (var part in parts)
        {
            if (part.Length > 0)
            {
                sb.Append(char.ToUpper(part[0]));
                if (part.Length > 1)
                {
                    sb.Append(part.Substring(1).ToLower());
                }
            }
        }
        
        return sb.ToString();
    }
}
